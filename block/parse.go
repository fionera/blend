// NOTE: this file has been automatically generated by blendef for Blender v305.

package block

import (
	"encoding/binary"
	"encoding/hex"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"os"
)

// ParseBody parses the block body and stores it in blk.Body. It is safe to call
// ParseBody multiple times on the same block.
func (blk *Block) ParseBody(order binary.ByteOrder, dna *DNA) (err error) {
	// Get block body reader.
	r, ok := blk.Body.(io.Reader)
	if !ok {
		// Body has already been parsed.
		return nil
	}

	index := blk.Hdr.SDNAIndex
	if index == 0 {
		// Parse based on block code.
		switch blk.Hdr.Code {
		case CodeDATA:
			blk.Body, err = ioutil.ReadAll(r)
			if err != nil {
				return err
			}
		case CodeDNA1:
			blk.Body, err = ParseDNA(r, order)
			if err != nil {
				return err
			}
		case CodeREND, CodeTEST:
			/// TODO: implement specific block body parsing for REND and TEST.
			blk.Body, err = ioutil.ReadAll(r)
			if err != nil {
				return err
			}
		default:
			return fmt.Errorf("Block.ParseBody: parsing of %q not yet implemented", blk.Hdr.Code)
		}
	} else {
		// Parse based on SDNA index.
		typ := dna.Structs[index].Type
		switch typ {
		case "ARegion":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ARegion, blk.Hdr.Count)
				for i := range bodies {
					body := new(ARegion)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ARegion)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ARegion_Runtime":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ARegion_Runtime, blk.Hdr.Count)
				for i := range bodies {
					body := new(ARegion_Runtime)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ARegion_Runtime)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "AnimData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*AnimData, blk.Hdr.Count)
				for i := range bodies {
					body := new(AnimData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(AnimData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "AnimOverride":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*AnimOverride, blk.Hdr.Count)
				for i := range bodies {
					body := new(AnimOverride)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(AnimOverride)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ArmatureGpencilModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ArmatureGpencilModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(ArmatureGpencilModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ArmatureGpencilModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ArmatureModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ArmatureModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(ArmatureModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ArmatureModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ArrayGpencilModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ArrayGpencilModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(ArrayGpencilModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ArrayGpencilModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ArrayModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ArrayModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(ArrayModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ArrayModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "AssetLibraryReference":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*AssetLibraryReference, blk.Hdr.Count)
				for i := range bodies {
					body := new(AssetLibraryReference)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(AssetLibraryReference)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "AssetMetaData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*AssetMetaData, blk.Hdr.Count)
				for i := range bodies {
					body := new(AssetMetaData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(AssetMetaData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "AssetTag":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*AssetTag, blk.Hdr.Count)
				for i := range bodies {
					body := new(AssetTag)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(AssetTag)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "AudioData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*AudioData, blk.Hdr.Count)
				for i := range bodies {
					body := new(AudioData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(AudioData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "AviCodecData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*AviCodecData, blk.Hdr.Count)
				for i := range bodies {
					body := new(AviCodecData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(AviCodecData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "BPoint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BPoint, blk.Hdr.Count)
				for i := range bodies {
					body := new(BPoint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BPoint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "BakeData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BakeData, blk.Hdr.Count)
				for i := range bodies {
					body := new(BakeData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BakeData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "Base":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Base, blk.Hdr.Count)
				for i := range bodies {
					body := new(Base)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Base)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "BevelModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BevelModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(BevelModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BevelModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "BezTriple":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BezTriple, blk.Hdr.Count)
				for i := range bodies {
					body := new(BezTriple)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BezTriple)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "BlurShaderFxData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BlurShaderFxData, blk.Hdr.Count)
				for i := range bodies {
					body := new(BlurShaderFxData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BlurShaderFxData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "BoidData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BoidData, blk.Hdr.Count)
				for i := range bodies {
					body := new(BoidData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BoidData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "BoidParticle":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BoidParticle, blk.Hdr.Count)
				for i := range bodies {
					body := new(BoidParticle)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BoidParticle)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "BoidRule":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BoidRule, blk.Hdr.Count)
				for i := range bodies {
					body := new(BoidRule)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BoidRule)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "BoidRuleAverageSpeed":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BoidRuleAverageSpeed, blk.Hdr.Count)
				for i := range bodies {
					body := new(BoidRuleAverageSpeed)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BoidRuleAverageSpeed)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "BoidRuleAvoidCollision":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BoidRuleAvoidCollision, blk.Hdr.Count)
				for i := range bodies {
					body := new(BoidRuleAvoidCollision)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BoidRuleAvoidCollision)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "BoidRuleFight":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BoidRuleFight, blk.Hdr.Count)
				for i := range bodies {
					body := new(BoidRuleFight)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BoidRuleFight)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "BoidRuleFollowLeader":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BoidRuleFollowLeader, blk.Hdr.Count)
				for i := range bodies {
					body := new(BoidRuleFollowLeader)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BoidRuleFollowLeader)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "BoidRuleGoalAvoid":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BoidRuleGoalAvoid, blk.Hdr.Count)
				for i := range bodies {
					body := new(BoidRuleGoalAvoid)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BoidRuleGoalAvoid)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "BoidSettings":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BoidSettings, blk.Hdr.Count)
				for i := range bodies {
					body := new(BoidSettings)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BoidSettings)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "BoidState":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BoidState, blk.Hdr.Count)
				for i := range bodies {
					body := new(BoidState)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BoidState)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "Bone":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Bone, blk.Hdr.Count)
				for i := range bodies {
					body := new(Bone)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Bone)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "BooleanModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BooleanModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(BooleanModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BooleanModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "BoundBox":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BoundBox, blk.Hdr.Count)
				for i := range bodies {
					body := new(BoundBox)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BoundBox)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "BrightContrastModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BrightContrastModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(BrightContrastModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BrightContrastModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "Brush":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Brush, blk.Hdr.Count)
				for i := range bodies {
					body := new(Brush)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Brush)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "BrushClone":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BrushClone, blk.Hdr.Count)
				for i := range bodies {
					body := new(BrushClone)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BrushClone)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "BrushCurvesSculptSettings":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BrushCurvesSculptSettings, blk.Hdr.Count)
				for i := range bodies {
					body := new(BrushCurvesSculptSettings)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BrushCurvesSculptSettings)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "BrushGpencilSettings":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BrushGpencilSettings, blk.Hdr.Count)
				for i := range bodies {
					body := new(BrushGpencilSettings)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BrushGpencilSettings)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "BuildEff":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BuildEff, blk.Hdr.Count)
				for i := range bodies {
					body := new(BuildEff)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BuildEff)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "BuildGpencilModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BuildGpencilModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(BuildGpencilModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BuildGpencilModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "BuildModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BuildModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(BuildModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BuildModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "CBData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*CBData, blk.Hdr.Count)
				for i := range bodies {
					body := new(CBData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(CBData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "CacheFile":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*CacheFile, blk.Hdr.Count)
				for i := range bodies {
					body := new(CacheFile)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(CacheFile)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "CacheFileLayer":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*CacheFileLayer, blk.Hdr.Count)
				for i := range bodies {
					body := new(CacheFileLayer)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(CacheFileLayer)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "CacheObjectPath":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*CacheObjectPath, blk.Hdr.Count)
				for i := range bodies {
					body := new(CacheObjectPath)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(CacheObjectPath)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "Camera":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Camera, blk.Hdr.Count)
				for i := range bodies {
					body := new(Camera)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Camera)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "CameraBGImage":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*CameraBGImage, blk.Hdr.Count)
				for i := range bodies {
					body := new(CameraBGImage)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(CameraBGImage)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "CameraDOFSettings":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*CameraDOFSettings, blk.Hdr.Count)
				for i := range bodies {
					body := new(CameraDOFSettings)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(CameraDOFSettings)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "CameraStereoSettings":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*CameraStereoSettings, blk.Hdr.Count)
				for i := range bodies {
					body := new(CameraStereoSettings)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(CameraStereoSettings)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "Camera_Runtime":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Camera_Runtime, blk.Hdr.Count)
				for i := range bodies {
					body := new(Camera_Runtime)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Camera_Runtime)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "CastModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*CastModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(CastModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(CastModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ChannelDriver":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ChannelDriver, blk.Hdr.Count)
				for i := range bodies {
					body := new(ChannelDriver)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ChannelDriver)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "CharInfo":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*CharInfo, blk.Hdr.Count)
				for i := range bodies {
					body := new(CharInfo)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(CharInfo)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ChildParticle":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ChildParticle, blk.Hdr.Count)
				for i := range bodies {
					body := new(ChildParticle)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ChildParticle)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ClothCollSettings":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ClothCollSettings, blk.Hdr.Count)
				for i := range bodies {
					body := new(ClothCollSettings)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ClothCollSettings)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ClothModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ClothModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(ClothModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ClothModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ClothSimSettings":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ClothSimSettings, blk.Hdr.Count)
				for i := range bodies {
					body := new(ClothSimSettings)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ClothSimSettings)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "Collection":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Collection, blk.Hdr.Count)
				for i := range bodies {
					body := new(Collection)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Collection)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "CollectionChild":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*CollectionChild, blk.Hdr.Count)
				for i := range bodies {
					body := new(CollectionChild)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(CollectionChild)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "CollectionObject":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*CollectionObject, blk.Hdr.Count)
				for i := range bodies {
					body := new(CollectionObject)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(CollectionObject)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "Collection_Runtime":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Collection_Runtime, blk.Hdr.Count)
				for i := range bodies {
					body := new(Collection_Runtime)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Collection_Runtime)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "CollisionModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*CollisionModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(CollisionModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(CollisionModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ColorBalanceModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ColorBalanceModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(ColorBalanceModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ColorBalanceModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ColorBand":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ColorBand, blk.Hdr.Count)
				for i := range bodies {
					body := new(ColorBand)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ColorBand)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ColorCorrectionData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ColorCorrectionData, blk.Hdr.Count)
				for i := range bodies {
					body := new(ColorCorrectionData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ColorCorrectionData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ColorGpencilModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ColorGpencilModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(ColorGpencilModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ColorGpencilModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ColorManagedColorspaceSettings":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ColorManagedColorspaceSettings, blk.Hdr.Count)
				for i := range bodies {
					body := new(ColorManagedColorspaceSettings)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ColorManagedColorspaceSettings)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ColorManagedDisplaySettings":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ColorManagedDisplaySettings, blk.Hdr.Count)
				for i := range bodies {
					body := new(ColorManagedDisplaySettings)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ColorManagedDisplaySettings)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ColorManagedViewSettings":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ColorManagedViewSettings, blk.Hdr.Count)
				for i := range bodies {
					body := new(ColorManagedViewSettings)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ColorManagedViewSettings)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ColorMapping":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ColorMapping, blk.Hdr.Count)
				for i := range bodies {
					body := new(ColorMapping)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ColorMapping)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ColorMixVars":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ColorMixVars, blk.Hdr.Count)
				for i := range bodies {
					body := new(ColorMixVars)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ColorMixVars)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ColorizeShaderFxData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ColorizeShaderFxData, blk.Hdr.Count)
				for i := range bodies {
					body := new(ColorizeShaderFxData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ColorizeShaderFxData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ConsoleLine":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ConsoleLine, blk.Hdr.Count)
				for i := range bodies {
					body := new(ConsoleLine)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ConsoleLine)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "CorrectiveSmoothDeltaCache":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*CorrectiveSmoothDeltaCache, blk.Hdr.Count)
				for i := range bodies {
					body := new(CorrectiveSmoothDeltaCache)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(CorrectiveSmoothDeltaCache)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "CorrectiveSmoothModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*CorrectiveSmoothModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(CorrectiveSmoothModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(CorrectiveSmoothModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "CryptomatteEntry":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*CryptomatteEntry, blk.Hdr.Count)
				for i := range bodies {
					body := new(CryptomatteEntry)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(CryptomatteEntry)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "CryptomatteLayer":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*CryptomatteLayer, blk.Hdr.Count)
				for i := range bodies {
					body := new(CryptomatteLayer)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(CryptomatteLayer)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "Curve":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Curve, blk.Hdr.Count)
				for i := range bodies {
					body := new(Curve)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Curve)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "CurveMap":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*CurveMap, blk.Hdr.Count)
				for i := range bodies {
					body := new(CurveMap)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(CurveMap)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "CurveMapPoint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*CurveMapPoint, blk.Hdr.Count)
				for i := range bodies {
					body := new(CurveMapPoint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(CurveMapPoint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "CurveMapping":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*CurveMapping, blk.Hdr.Count)
				for i := range bodies {
					body := new(CurveMapping)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(CurveMapping)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "CurveModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*CurveModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(CurveModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(CurveModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "CurvePaintSettings":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*CurvePaintSettings, blk.Hdr.Count)
				for i := range bodies {
					body := new(CurvePaintSettings)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(CurvePaintSettings)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "CurveProfile":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*CurveProfile, blk.Hdr.Count)
				for i := range bodies {
					body := new(CurveProfile)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(CurveProfile)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "CurveProfilePoint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*CurveProfilePoint, blk.Hdr.Count)
				for i := range bodies {
					body := new(CurveProfilePoint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(CurveProfilePoint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "Curves":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Curves, blk.Hdr.Count)
				for i := range bodies {
					body := new(Curves)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Curves)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "CurvesGeometry":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*CurvesGeometry, blk.Hdr.Count)
				for i := range bodies {
					body := new(CurvesGeometry)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(CurvesGeometry)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "CurvesModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*CurvesModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(CurvesModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(CurvesModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "CurvesSculpt":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*CurvesSculpt, blk.Hdr.Count)
				for i := range bodies {
					body := new(CurvesSculpt)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(CurvesSculpt)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "CustomData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*CustomData, blk.Hdr.Count)
				for i := range bodies {
					body := new(CustomData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(CustomData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "CustomDataExternal":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*CustomDataExternal, blk.Hdr.Count)
				for i := range bodies {
					body := new(CustomDataExternal)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(CustomDataExternal)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "CustomDataLayer":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*CustomDataLayer, blk.Hdr.Count)
				for i := range bodies {
					body := new(CustomDataLayer)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(CustomDataLayer)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "CustomData_MeshMasks":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*CustomData_MeshMasks, blk.Hdr.Count)
				for i := range bodies {
					body := new(CustomData_MeshMasks)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(CustomData_MeshMasks)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "DashGpencilModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*DashGpencilModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(DashGpencilModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(DashGpencilModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "DashGpencilModifierSegment":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*DashGpencilModifierSegment, blk.Hdr.Count)
				for i := range bodies {
					body := new(DashGpencilModifierSegment)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(DashGpencilModifierSegment)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "DataTransferModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*DataTransferModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(DataTransferModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(DataTransferModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "DecimateModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*DecimateModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(DecimateModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(DecimateModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "DisplaceModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*DisplaceModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(DisplaceModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(DisplaceModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "DisplaySafeAreas":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*DisplaySafeAreas, blk.Hdr.Count)
				for i := range bodies {
					body := new(DisplaySafeAreas)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(DisplaySafeAreas)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "DrawDataList":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*DrawDataList, blk.Hdr.Count)
				for i := range bodies {
					body := new(DrawDataList)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(DrawDataList)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "DriverTarget":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*DriverTarget, blk.Hdr.Count)
				for i := range bodies {
					body := new(DriverTarget)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(DriverTarget)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "DriverVar":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*DriverVar, blk.Hdr.Count)
				for i := range bodies {
					body := new(DriverVar)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(DriverVar)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "DualQuat":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*DualQuat, blk.Hdr.Count)
				for i := range bodies {
					body := new(DualQuat)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(DualQuat)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "DynamicPaintBrushSettings":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*DynamicPaintBrushSettings, blk.Hdr.Count)
				for i := range bodies {
					body := new(DynamicPaintBrushSettings)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(DynamicPaintBrushSettings)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "DynamicPaintCanvasSettings":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*DynamicPaintCanvasSettings, blk.Hdr.Count)
				for i := range bodies {
					body := new(DynamicPaintCanvasSettings)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(DynamicPaintCanvasSettings)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "DynamicPaintModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*DynamicPaintModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(DynamicPaintModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(DynamicPaintModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "DynamicPaintSurface":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*DynamicPaintSurface, blk.Hdr.Count)
				for i := range bodies {
					body := new(DynamicPaintSurface)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(DynamicPaintSurface)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "EdgeSplitModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*EdgeSplitModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(EdgeSplitModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(EdgeSplitModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "Editing":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Editing, blk.Hdr.Count)
				for i := range bodies {
					body := new(Editing)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Editing)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "EditingRuntime":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*EditingRuntime, blk.Hdr.Count)
				for i := range bodies {
					body := new(EditingRuntime)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(EditingRuntime)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "Effect":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Effect, blk.Hdr.Count)
				for i := range bodies {
					body := new(Effect)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Effect)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "EffectorWeights":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*EffectorWeights, blk.Hdr.Count)
				for i := range bodies {
					body := new(EffectorWeights)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(EffectorWeights)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "EnvelopeGpencilModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*EnvelopeGpencilModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(EnvelopeGpencilModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(EnvelopeGpencilModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ExplodeModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ExplodeModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(ExplodeModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ExplodeModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "FCM_EnvelopeData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*FCM_EnvelopeData, blk.Hdr.Count)
				for i := range bodies {
					body := new(FCM_EnvelopeData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(FCM_EnvelopeData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "FCurve":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*FCurve, blk.Hdr.Count)
				for i := range bodies {
					body := new(FCurve)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(FCurve)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "FFMpegCodecData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*FFMpegCodecData, blk.Hdr.Count)
				for i := range bodies {
					body := new(FFMpegCodecData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(FFMpegCodecData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "FMod_Cycles":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*FMod_Cycles, blk.Hdr.Count)
				for i := range bodies {
					body := new(FMod_Cycles)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(FMod_Cycles)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "FMod_Envelope":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*FMod_Envelope, blk.Hdr.Count)
				for i := range bodies {
					body := new(FMod_Envelope)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(FMod_Envelope)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "FMod_FunctionGenerator":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*FMod_FunctionGenerator, blk.Hdr.Count)
				for i := range bodies {
					body := new(FMod_FunctionGenerator)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(FMod_FunctionGenerator)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "FMod_Generator":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*FMod_Generator, blk.Hdr.Count)
				for i := range bodies {
					body := new(FMod_Generator)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(FMod_Generator)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "FMod_Limits":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*FMod_Limits, blk.Hdr.Count)
				for i := range bodies {
					body := new(FMod_Limits)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(FMod_Limits)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "FMod_Noise":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*FMod_Noise, blk.Hdr.Count)
				for i := range bodies {
					body := new(FMod_Noise)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(FMod_Noise)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "FMod_Python":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*FMod_Python, blk.Hdr.Count)
				for i := range bodies {
					body := new(FMod_Python)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(FMod_Python)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "FMod_Stepped":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*FMod_Stepped, blk.Hdr.Count)
				for i := range bodies {
					body := new(FMod_Stepped)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(FMod_Stepped)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "FModifier":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*FModifier, blk.Hdr.Count)
				for i := range bodies {
					body := new(FModifier)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(FModifier)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "FPoint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*FPoint, blk.Hdr.Count)
				for i := range bodies {
					body := new(FPoint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(FPoint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "FileAssetSelectParams":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*FileAssetSelectParams, blk.Hdr.Count)
				for i := range bodies {
					body := new(FileAssetSelectParams)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(FileAssetSelectParams)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "FileFolderHistory":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*FileFolderHistory, blk.Hdr.Count)
				for i := range bodies {
					body := new(FileFolderHistory)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(FileFolderHistory)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "FileGlobal":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*FileGlobal, blk.Hdr.Count)
				for i := range bodies {
					body := new(FileGlobal)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(FileGlobal)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "FileSelectParams":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*FileSelectParams, blk.Hdr.Count)
				for i := range bodies {
					body := new(FileSelectParams)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(FileSelectParams)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "FlipShaderFxData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*FlipShaderFxData, blk.Hdr.Count)
				for i := range bodies {
					body := new(FlipShaderFxData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(FlipShaderFxData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "FluidDomainSettings":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*FluidDomainSettings, blk.Hdr.Count)
				for i := range bodies {
					body := new(FluidDomainSettings)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(FluidDomainSettings)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "FluidEffectorSettings":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*FluidEffectorSettings, blk.Hdr.Count)
				for i := range bodies {
					body := new(FluidEffectorSettings)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(FluidEffectorSettings)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "FluidFlowSettings":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*FluidFlowSettings, blk.Hdr.Count)
				for i := range bodies {
					body := new(FluidFlowSettings)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(FluidFlowSettings)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "FluidModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*FluidModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(FluidModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(FluidModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "FluidVertexVelocity":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*FluidVertexVelocity, blk.Hdr.Count)
				for i := range bodies {
					body := new(FluidVertexVelocity)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(FluidVertexVelocity)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "FluidsimModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*FluidsimModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(FluidsimModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(FluidsimModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "FluidsimSettings":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*FluidsimSettings, blk.Hdr.Count)
				for i := range bodies {
					body := new(FluidsimSettings)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(FluidsimSettings)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "FreestyleConfig":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*FreestyleConfig, blk.Hdr.Count)
				for i := range bodies {
					body := new(FreestyleConfig)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(FreestyleConfig)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "FreestyleEdge":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*FreestyleEdge, blk.Hdr.Count)
				for i := range bodies {
					body := new(FreestyleEdge)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(FreestyleEdge)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "FreestyleFace":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*FreestyleFace, blk.Hdr.Count)
				for i := range bodies {
					body := new(FreestyleFace)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(FreestyleFace)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "FreestyleLineSet":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*FreestyleLineSet, blk.Hdr.Count)
				for i := range bodies {
					body := new(FreestyleLineSet)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(FreestyleLineSet)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "FreestyleLineStyle":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*FreestyleLineStyle, blk.Hdr.Count)
				for i := range bodies {
					body := new(FreestyleLineStyle)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(FreestyleLineStyle)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "FreestyleModuleConfig":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*FreestyleModuleConfig, blk.Hdr.Count)
				for i := range bodies {
					body := new(FreestyleModuleConfig)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(FreestyleModuleConfig)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "GPUDOFSettings":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*GPUDOFSettings, blk.Hdr.Count)
				for i := range bodies {
					body := new(GPUDOFSettings)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(GPUDOFSettings)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "GP_Interpolate_Settings":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*GP_Interpolate_Settings, blk.Hdr.Count)
				for i := range bodies {
					body := new(GP_Interpolate_Settings)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(GP_Interpolate_Settings)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "GP_Sculpt_Guide":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*GP_Sculpt_Guide, blk.Hdr.Count)
				for i := range bodies {
					body := new(GP_Sculpt_Guide)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(GP_Sculpt_Guide)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "GP_Sculpt_Settings":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*GP_Sculpt_Settings, blk.Hdr.Count)
				for i := range bodies {
					body := new(GP_Sculpt_Settings)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(GP_Sculpt_Settings)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "GaussianBlurVars":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*GaussianBlurVars, blk.Hdr.Count)
				for i := range bodies {
					body := new(GaussianBlurVars)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(GaussianBlurVars)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "GlowShaderFxData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*GlowShaderFxData, blk.Hdr.Count)
				for i := range bodies {
					body := new(GlowShaderFxData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(GlowShaderFxData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "GlowVars":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*GlowVars, blk.Hdr.Count)
				for i := range bodies {
					body := new(GlowVars)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(GlowVars)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "GpPaint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*GpPaint, blk.Hdr.Count)
				for i := range bodies {
					body := new(GpPaint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(GpPaint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "GpSculptPaint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*GpSculptPaint, blk.Hdr.Count)
				for i := range bodies {
					body := new(GpSculptPaint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(GpSculptPaint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "GpVertexPaint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*GpVertexPaint, blk.Hdr.Count)
				for i := range bodies {
					body := new(GpVertexPaint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(GpVertexPaint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "GpWeightPaint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*GpWeightPaint, blk.Hdr.Count)
				for i := range bodies {
					body := new(GpWeightPaint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(GpWeightPaint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "GpencilModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*GpencilModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(GpencilModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(GpencilModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "GridPaintMask":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*GridPaintMask, blk.Hdr.Count)
				for i := range bodies {
					body := new(GridPaintMask)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(GridPaintMask)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "HairKey":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*HairKey, blk.Hdr.Count)
				for i := range bodies {
					body := new(HairKey)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(HairKey)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "Histogram":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Histogram, blk.Hdr.Count)
				for i := range bodies {
					body := new(Histogram)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Histogram)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "HookGpencilModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*HookGpencilModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(HookGpencilModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(HookGpencilModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "HookModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*HookModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(HookModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(HookModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "HueCorrectModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*HueCorrectModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(HueCorrectModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(HueCorrectModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ID":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ID, blk.Hdr.Count)
				for i := range bodies {
					body := new(ID)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ID)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "IDOverrideLibrary":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*IDOverrideLibrary, blk.Hdr.Count)
				for i := range bodies {
					body := new(IDOverrideLibrary)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(IDOverrideLibrary)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "IDOverrideLibraryProperty":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*IDOverrideLibraryProperty, blk.Hdr.Count)
				for i := range bodies {
					body := new(IDOverrideLibraryProperty)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(IDOverrideLibraryProperty)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "IDOverrideLibraryPropertyOperation":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*IDOverrideLibraryPropertyOperation, blk.Hdr.Count)
				for i := range bodies {
					body := new(IDOverrideLibraryPropertyOperation)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(IDOverrideLibraryPropertyOperation)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "IDProperty":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*IDProperty, blk.Hdr.Count)
				for i := range bodies {
					body := new(IDProperty)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(IDProperty)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "IDPropertyData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*IDPropertyData, blk.Hdr.Count)
				for i := range bodies {
					body := new(IDPropertyData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(IDPropertyData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "IDPropertyUIData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*IDPropertyUIData, blk.Hdr.Count)
				for i := range bodies {
					body := new(IDPropertyUIData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(IDPropertyUIData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "IDPropertyUIDataBool":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*IDPropertyUIDataBool, blk.Hdr.Count)
				for i := range bodies {
					body := new(IDPropertyUIDataBool)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(IDPropertyUIDataBool)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "IDPropertyUIDataFloat":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*IDPropertyUIDataFloat, blk.Hdr.Count)
				for i := range bodies {
					body := new(IDPropertyUIDataFloat)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(IDPropertyUIDataFloat)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "IDPropertyUIDataID":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*IDPropertyUIDataID, blk.Hdr.Count)
				for i := range bodies {
					body := new(IDPropertyUIDataID)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(IDPropertyUIDataID)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "IDPropertyUIDataInt":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*IDPropertyUIDataInt, blk.Hdr.Count)
				for i := range bodies {
					body := new(IDPropertyUIDataInt)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(IDPropertyUIDataInt)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "IDPropertyUIDataString":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*IDPropertyUIDataString, blk.Hdr.Count)
				for i := range bodies {
					body := new(IDPropertyUIDataString)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(IDPropertyUIDataString)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "IDViewerPathElem":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*IDViewerPathElem, blk.Hdr.Count)
				for i := range bodies {
					body := new(IDViewerPathElem)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(IDViewerPathElem)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ID_Runtime":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ID_Runtime, blk.Hdr.Count)
				for i := range bodies {
					body := new(ID_Runtime)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ID_Runtime)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ID_Runtime_Remap":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ID_Runtime_Remap, blk.Hdr.Count)
				for i := range bodies {
					body := new(ID_Runtime_Remap)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ID_Runtime_Remap)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "IdAdtTemplate":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*IdAdtTemplate, blk.Hdr.Count)
				for i := range bodies {
					body := new(IdAdtTemplate)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(IdAdtTemplate)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "Image":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Image, blk.Hdr.Count)
				for i := range bodies {
					body := new(Image)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Image)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ImageAnim":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ImageAnim, blk.Hdr.Count)
				for i := range bodies {
					body := new(ImageAnim)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ImageAnim)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ImageFormatData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ImageFormatData, blk.Hdr.Count)
				for i := range bodies {
					body := new(ImageFormatData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ImageFormatData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ImagePackedFile":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ImagePackedFile, blk.Hdr.Count)
				for i := range bodies {
					body := new(ImagePackedFile)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ImagePackedFile)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ImagePaintSettings":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ImagePaintSettings, blk.Hdr.Count)
				for i := range bodies {
					body := new(ImagePaintSettings)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ImagePaintSettings)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ImageTile":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ImageTile, blk.Hdr.Count)
				for i := range bodies {
					body := new(ImageTile)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ImageTile)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ImageTile_Runtime":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ImageTile_Runtime, blk.Hdr.Count)
				for i := range bodies {
					body := new(ImageTile_Runtime)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ImageTile_Runtime)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ImageUser":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ImageUser, blk.Hdr.Count)
				for i := range bodies {
					body := new(ImageUser)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ImageUser)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ImageView":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ImageView, blk.Hdr.Count)
				for i := range bodies {
					body := new(ImageView)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ImageView)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "Image_Runtime":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Image_Runtime, blk.Hdr.Count)
				for i := range bodies {
					body := new(Image_Runtime)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Image_Runtime)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "Ipo":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Ipo, blk.Hdr.Count)
				for i := range bodies {
					body := new(Ipo)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Ipo)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "IpoCurve":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*IpoCurve, blk.Hdr.Count)
				for i := range bodies {
					body := new(IpoCurve)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(IpoCurve)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "IpoDriver":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*IpoDriver, blk.Hdr.Count)
				for i := range bodies {
					body := new(IpoDriver)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(IpoDriver)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "KS_Path":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*KS_Path, blk.Hdr.Count)
				for i := range bodies {
					body := new(KS_Path)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(KS_Path)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "Key":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Key, blk.Hdr.Count)
				for i := range bodies {
					body := new(Key)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Key)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "KeyBlock":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*KeyBlock, blk.Hdr.Count)
				for i := range bodies {
					body := new(KeyBlock)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(KeyBlock)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "KeyingSet":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*KeyingSet, blk.Hdr.Count)
				for i := range bodies {
					body := new(KeyingSet)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(KeyingSet)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "Lamp":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Lamp, blk.Hdr.Count)
				for i := range bodies {
					body := new(Lamp)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Lamp)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LaplacianDeformModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LaplacianDeformModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(LaplacianDeformModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LaplacianDeformModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LaplacianSmoothModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LaplacianSmoothModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(LaplacianSmoothModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LaplacianSmoothModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "Lattice":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Lattice, blk.Hdr.Count)
				for i := range bodies {
					body := new(Lattice)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Lattice)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LatticeGpencilModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LatticeGpencilModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(LatticeGpencilModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LatticeGpencilModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LatticeModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LatticeModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(LatticeModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LatticeModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LayerCollection":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LayerCollection, blk.Hdr.Count)
				for i := range bodies {
					body := new(LayerCollection)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LayerCollection)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LengthGpencilModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LengthGpencilModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(LengthGpencilModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LengthGpencilModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "Library":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Library, blk.Hdr.Count)
				for i := range bodies {
					body := new(Library)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Library)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LibraryWeakReference":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LibraryWeakReference, blk.Hdr.Count)
				for i := range bodies {
					body := new(LibraryWeakReference)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LibraryWeakReference)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "Library_Runtime":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Library_Runtime, blk.Hdr.Count)
				for i := range bodies {
					body := new(Library_Runtime)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Library_Runtime)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LightCache":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LightCache, blk.Hdr.Count)
				for i := range bodies {
					body := new(LightCache)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LightCache)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LightCacheTexture":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LightCacheTexture, blk.Hdr.Count)
				for i := range bodies {
					body := new(LightCacheTexture)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LightCacheTexture)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LightGridCache":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LightGridCache, blk.Hdr.Count)
				for i := range bodies {
					body := new(LightGridCache)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LightGridCache)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LightProbe":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LightProbe, blk.Hdr.Count)
				for i := range bodies {
					body := new(LightProbe)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LightProbe)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LightProbeCache":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LightProbeCache, blk.Hdr.Count)
				for i := range bodies {
					body := new(LightProbeCache)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LightProbeCache)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LightgroupMembership":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LightgroupMembership, blk.Hdr.Count)
				for i := range bodies {
					body := new(LightgroupMembership)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LightgroupMembership)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LineStyleAlphaModifier_AlongStroke":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LineStyleAlphaModifier_AlongStroke, blk.Hdr.Count)
				for i := range bodies {
					body := new(LineStyleAlphaModifier_AlongStroke)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LineStyleAlphaModifier_AlongStroke)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LineStyleAlphaModifier_CreaseAngle":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LineStyleAlphaModifier_CreaseAngle, blk.Hdr.Count)
				for i := range bodies {
					body := new(LineStyleAlphaModifier_CreaseAngle)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LineStyleAlphaModifier_CreaseAngle)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LineStyleAlphaModifier_Curvature_3D":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LineStyleAlphaModifier_Curvature_3D, blk.Hdr.Count)
				for i := range bodies {
					body := new(LineStyleAlphaModifier_Curvature_3D)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LineStyleAlphaModifier_Curvature_3D)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LineStyleAlphaModifier_DistanceFromCamera":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LineStyleAlphaModifier_DistanceFromCamera, blk.Hdr.Count)
				for i := range bodies {
					body := new(LineStyleAlphaModifier_DistanceFromCamera)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LineStyleAlphaModifier_DistanceFromCamera)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LineStyleAlphaModifier_DistanceFromObject":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LineStyleAlphaModifier_DistanceFromObject, blk.Hdr.Count)
				for i := range bodies {
					body := new(LineStyleAlphaModifier_DistanceFromObject)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LineStyleAlphaModifier_DistanceFromObject)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LineStyleAlphaModifier_Material":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LineStyleAlphaModifier_Material, blk.Hdr.Count)
				for i := range bodies {
					body := new(LineStyleAlphaModifier_Material)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LineStyleAlphaModifier_Material)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LineStyleAlphaModifier_Noise":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LineStyleAlphaModifier_Noise, blk.Hdr.Count)
				for i := range bodies {
					body := new(LineStyleAlphaModifier_Noise)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LineStyleAlphaModifier_Noise)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LineStyleAlphaModifier_Tangent":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LineStyleAlphaModifier_Tangent, blk.Hdr.Count)
				for i := range bodies {
					body := new(LineStyleAlphaModifier_Tangent)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LineStyleAlphaModifier_Tangent)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LineStyleColorModifier_AlongStroke":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LineStyleColorModifier_AlongStroke, blk.Hdr.Count)
				for i := range bodies {
					body := new(LineStyleColorModifier_AlongStroke)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LineStyleColorModifier_AlongStroke)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LineStyleColorModifier_CreaseAngle":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LineStyleColorModifier_CreaseAngle, blk.Hdr.Count)
				for i := range bodies {
					body := new(LineStyleColorModifier_CreaseAngle)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LineStyleColorModifier_CreaseAngle)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LineStyleColorModifier_Curvature_3D":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LineStyleColorModifier_Curvature_3D, blk.Hdr.Count)
				for i := range bodies {
					body := new(LineStyleColorModifier_Curvature_3D)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LineStyleColorModifier_Curvature_3D)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LineStyleColorModifier_DistanceFromCamera":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LineStyleColorModifier_DistanceFromCamera, blk.Hdr.Count)
				for i := range bodies {
					body := new(LineStyleColorModifier_DistanceFromCamera)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LineStyleColorModifier_DistanceFromCamera)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LineStyleColorModifier_DistanceFromObject":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LineStyleColorModifier_DistanceFromObject, blk.Hdr.Count)
				for i := range bodies {
					body := new(LineStyleColorModifier_DistanceFromObject)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LineStyleColorModifier_DistanceFromObject)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LineStyleColorModifier_Material":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LineStyleColorModifier_Material, blk.Hdr.Count)
				for i := range bodies {
					body := new(LineStyleColorModifier_Material)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LineStyleColorModifier_Material)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LineStyleColorModifier_Noise":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LineStyleColorModifier_Noise, blk.Hdr.Count)
				for i := range bodies {
					body := new(LineStyleColorModifier_Noise)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LineStyleColorModifier_Noise)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LineStyleColorModifier_Tangent":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LineStyleColorModifier_Tangent, blk.Hdr.Count)
				for i := range bodies {
					body := new(LineStyleColorModifier_Tangent)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LineStyleColorModifier_Tangent)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LineStyleGeometryModifier_2DOffset":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LineStyleGeometryModifier_2DOffset, blk.Hdr.Count)
				for i := range bodies {
					body := new(LineStyleGeometryModifier_2DOffset)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LineStyleGeometryModifier_2DOffset)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LineStyleGeometryModifier_2DTransform":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LineStyleGeometryModifier_2DTransform, blk.Hdr.Count)
				for i := range bodies {
					body := new(LineStyleGeometryModifier_2DTransform)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LineStyleGeometryModifier_2DTransform)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LineStyleGeometryModifier_BackboneStretcher":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LineStyleGeometryModifier_BackboneStretcher, blk.Hdr.Count)
				for i := range bodies {
					body := new(LineStyleGeometryModifier_BackboneStretcher)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LineStyleGeometryModifier_BackboneStretcher)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LineStyleGeometryModifier_BezierCurve":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LineStyleGeometryModifier_BezierCurve, blk.Hdr.Count)
				for i := range bodies {
					body := new(LineStyleGeometryModifier_BezierCurve)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LineStyleGeometryModifier_BezierCurve)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LineStyleGeometryModifier_Blueprint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LineStyleGeometryModifier_Blueprint, blk.Hdr.Count)
				for i := range bodies {
					body := new(LineStyleGeometryModifier_Blueprint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LineStyleGeometryModifier_Blueprint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LineStyleGeometryModifier_GuidingLines":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LineStyleGeometryModifier_GuidingLines, blk.Hdr.Count)
				for i := range bodies {
					body := new(LineStyleGeometryModifier_GuidingLines)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LineStyleGeometryModifier_GuidingLines)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LineStyleGeometryModifier_PerlinNoise1D":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LineStyleGeometryModifier_PerlinNoise1D, blk.Hdr.Count)
				for i := range bodies {
					body := new(LineStyleGeometryModifier_PerlinNoise1D)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LineStyleGeometryModifier_PerlinNoise1D)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LineStyleGeometryModifier_PerlinNoise2D":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LineStyleGeometryModifier_PerlinNoise2D, blk.Hdr.Count)
				for i := range bodies {
					body := new(LineStyleGeometryModifier_PerlinNoise2D)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LineStyleGeometryModifier_PerlinNoise2D)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LineStyleGeometryModifier_Polygonalization":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LineStyleGeometryModifier_Polygonalization, blk.Hdr.Count)
				for i := range bodies {
					body := new(LineStyleGeometryModifier_Polygonalization)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LineStyleGeometryModifier_Polygonalization)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LineStyleGeometryModifier_Sampling":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LineStyleGeometryModifier_Sampling, blk.Hdr.Count)
				for i := range bodies {
					body := new(LineStyleGeometryModifier_Sampling)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LineStyleGeometryModifier_Sampling)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LineStyleGeometryModifier_Simplification":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LineStyleGeometryModifier_Simplification, blk.Hdr.Count)
				for i := range bodies {
					body := new(LineStyleGeometryModifier_Simplification)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LineStyleGeometryModifier_Simplification)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LineStyleGeometryModifier_SinusDisplacement":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LineStyleGeometryModifier_SinusDisplacement, blk.Hdr.Count)
				for i := range bodies {
					body := new(LineStyleGeometryModifier_SinusDisplacement)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LineStyleGeometryModifier_SinusDisplacement)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LineStyleGeometryModifier_SpatialNoise":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LineStyleGeometryModifier_SpatialNoise, blk.Hdr.Count)
				for i := range bodies {
					body := new(LineStyleGeometryModifier_SpatialNoise)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LineStyleGeometryModifier_SpatialNoise)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LineStyleGeometryModifier_TipRemover":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LineStyleGeometryModifier_TipRemover, blk.Hdr.Count)
				for i := range bodies {
					body := new(LineStyleGeometryModifier_TipRemover)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LineStyleGeometryModifier_TipRemover)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LineStyleModifier":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LineStyleModifier, blk.Hdr.Count)
				for i := range bodies {
					body := new(LineStyleModifier)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LineStyleModifier)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LineStyleThicknessModifier_AlongStroke":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LineStyleThicknessModifier_AlongStroke, blk.Hdr.Count)
				for i := range bodies {
					body := new(LineStyleThicknessModifier_AlongStroke)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LineStyleThicknessModifier_AlongStroke)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LineStyleThicknessModifier_Calligraphy":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LineStyleThicknessModifier_Calligraphy, blk.Hdr.Count)
				for i := range bodies {
					body := new(LineStyleThicknessModifier_Calligraphy)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LineStyleThicknessModifier_Calligraphy)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LineStyleThicknessModifier_CreaseAngle":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LineStyleThicknessModifier_CreaseAngle, blk.Hdr.Count)
				for i := range bodies {
					body := new(LineStyleThicknessModifier_CreaseAngle)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LineStyleThicknessModifier_CreaseAngle)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LineStyleThicknessModifier_Curvature_3D":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LineStyleThicknessModifier_Curvature_3D, blk.Hdr.Count)
				for i := range bodies {
					body := new(LineStyleThicknessModifier_Curvature_3D)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LineStyleThicknessModifier_Curvature_3D)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LineStyleThicknessModifier_DistanceFromCamera":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LineStyleThicknessModifier_DistanceFromCamera, blk.Hdr.Count)
				for i := range bodies {
					body := new(LineStyleThicknessModifier_DistanceFromCamera)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LineStyleThicknessModifier_DistanceFromCamera)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LineStyleThicknessModifier_DistanceFromObject":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LineStyleThicknessModifier_DistanceFromObject, blk.Hdr.Count)
				for i := range bodies {
					body := new(LineStyleThicknessModifier_DistanceFromObject)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LineStyleThicknessModifier_DistanceFromObject)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LineStyleThicknessModifier_Material":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LineStyleThicknessModifier_Material, blk.Hdr.Count)
				for i := range bodies {
					body := new(LineStyleThicknessModifier_Material)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LineStyleThicknessModifier_Material)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LineStyleThicknessModifier_Noise":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LineStyleThicknessModifier_Noise, blk.Hdr.Count)
				for i := range bodies {
					body := new(LineStyleThicknessModifier_Noise)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LineStyleThicknessModifier_Noise)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LineStyleThicknessModifier_Tangent":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LineStyleThicknessModifier_Tangent, blk.Hdr.Count)
				for i := range bodies {
					body := new(LineStyleThicknessModifier_Tangent)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LineStyleThicknessModifier_Tangent)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LineartGpencilModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LineartGpencilModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(LineartGpencilModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LineartGpencilModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "Link":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Link, blk.Hdr.Count)
				for i := range bodies {
					body := new(Link)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Link)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "LinkData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*LinkData, blk.Hdr.Count)
				for i := range bodies {
					body := new(LinkData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(LinkData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ListBase":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ListBase, blk.Hdr.Count)
				for i := range bodies {
					body := new(ListBase)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ListBase)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MBoolProperty":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MBoolProperty, blk.Hdr.Count)
				for i := range bodies {
					body := new(MBoolProperty)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MBoolProperty)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MCol":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MCol, blk.Hdr.Count)
				for i := range bodies {
					body := new(MCol)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MCol)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MDefCell":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MDefCell, blk.Hdr.Count)
				for i := range bodies {
					body := new(MDefCell)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MDefCell)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MDefInfluence":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MDefInfluence, blk.Hdr.Count)
				for i := range bodies {
					body := new(MDefInfluence)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MDefInfluence)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MDeformVert":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MDeformVert, blk.Hdr.Count)
				for i := range bodies {
					body := new(MDeformVert)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MDeformVert)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MDeformWeight":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MDeformWeight, blk.Hdr.Count)
				for i := range bodies {
					body := new(MDeformWeight)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MDeformWeight)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MDisps":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MDisps, blk.Hdr.Count)
				for i := range bodies {
					body := new(MDisps)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MDisps)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MEdge":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MEdge, blk.Hdr.Count)
				for i := range bodies {
					body := new(MEdge)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MEdge)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MFace":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MFace, blk.Hdr.Count)
				for i := range bodies {
					body := new(MFace)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MFace)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MFloatProperty":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MFloatProperty, blk.Hdr.Count)
				for i := range bodies {
					body := new(MFloatProperty)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MFloatProperty)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MInt8Property":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MInt8Property, blk.Hdr.Count)
				for i := range bodies {
					body := new(MInt8Property)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MInt8Property)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MIntProperty":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MIntProperty, blk.Hdr.Count)
				for i := range bodies {
					body := new(MIntProperty)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MIntProperty)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MLoop":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MLoop, blk.Hdr.Count)
				for i := range bodies {
					body := new(MLoop)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MLoop)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MLoopCol":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MLoopCol, blk.Hdr.Count)
				for i := range bodies {
					body := new(MLoopCol)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MLoopCol)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MLoopTri":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MLoopTri, blk.Hdr.Count)
				for i := range bodies {
					body := new(MLoopTri)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MLoopTri)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MLoopUV":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MLoopUV, blk.Hdr.Count)
				for i := range bodies {
					body := new(MLoopUV)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MLoopUV)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MPoly":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MPoly, blk.Hdr.Count)
				for i := range bodies {
					body := new(MPoly)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MPoly)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MPropCol":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MPropCol, blk.Hdr.Count)
				for i := range bodies {
					body := new(MPropCol)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MPropCol)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MRecast":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MRecast, blk.Hdr.Count)
				for i := range bodies {
					body := new(MRecast)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MRecast)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MSelect":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MSelect, blk.Hdr.Count)
				for i := range bodies {
					body := new(MSelect)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MSelect)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MStringProperty":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MStringProperty, blk.Hdr.Count)
				for i := range bodies {
					body := new(MStringProperty)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MStringProperty)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MTFace":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MTFace, blk.Hdr.Count)
				for i := range bodies {
					body := new(MTFace)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MTFace)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MTex":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MTex, blk.Hdr.Count)
				for i := range bodies {
					body := new(MTex)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MTex)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MVert":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MVert, blk.Hdr.Count)
				for i := range bodies {
					body := new(MVert)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MVert)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MVertSkin":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MVertSkin, blk.Hdr.Count)
				for i := range bodies {
					body := new(MVertSkin)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MVertSkin)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MappingInfoModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MappingInfoModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(MappingInfoModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MappingInfoModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "Mask":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Mask, blk.Hdr.Count)
				for i := range bodies {
					body := new(Mask)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Mask)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MaskLayer":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MaskLayer, blk.Hdr.Count)
				for i := range bodies {
					body := new(MaskLayer)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MaskLayer)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MaskLayerShape":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MaskLayerShape, blk.Hdr.Count)
				for i := range bodies {
					body := new(MaskLayerShape)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MaskLayerShape)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MaskModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MaskModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(MaskModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MaskModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MaskParent":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MaskParent, blk.Hdr.Count)
				for i := range bodies {
					body := new(MaskParent)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MaskParent)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MaskSpaceInfo":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MaskSpaceInfo, blk.Hdr.Count)
				for i := range bodies {
					body := new(MaskSpaceInfo)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MaskSpaceInfo)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MaskSpline":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MaskSpline, blk.Hdr.Count)
				for i := range bodies {
					body := new(MaskSpline)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MaskSpline)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MaskSplinePoint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MaskSplinePoint, blk.Hdr.Count)
				for i := range bodies {
					body := new(MaskSplinePoint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MaskSplinePoint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MaskSplinePointUW":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MaskSplinePointUW, blk.Hdr.Count)
				for i := range bodies {
					body := new(MaskSplinePointUW)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MaskSplinePointUW)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "Material":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Material, blk.Hdr.Count)
				for i := range bodies {
					body := new(Material)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Material)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MaterialGPencilStyle":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MaterialGPencilStyle, blk.Hdr.Count)
				for i := range bodies {
					body := new(MaterialGPencilStyle)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MaterialGPencilStyle)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MaterialLineArt":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MaterialLineArt, blk.Hdr.Count)
				for i := range bodies {
					body := new(MaterialLineArt)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MaterialLineArt)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "Mesh":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Mesh, blk.Hdr.Count)
				for i := range bodies {
					body := new(Mesh)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Mesh)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MeshCacheModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MeshCacheModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(MeshCacheModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MeshCacheModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MeshDeformModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MeshDeformModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(MeshDeformModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MeshDeformModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MeshSeqCacheModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MeshSeqCacheModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(MeshSeqCacheModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MeshSeqCacheModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MeshStatVis":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MeshStatVis, blk.Hdr.Count)
				for i := range bodies {
					body := new(MeshStatVis)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MeshStatVis)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MeshToVolumeModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MeshToVolumeModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(MeshToVolumeModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MeshToVolumeModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MetaBall":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MetaBall, blk.Hdr.Count)
				for i := range bodies {
					body := new(MetaBall)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MetaBall)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MetaElem":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MetaElem, blk.Hdr.Count)
				for i := range bodies {
					body := new(MetaElem)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MetaElem)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MetaStack":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MetaStack, blk.Hdr.Count)
				for i := range bodies {
					body := new(MetaStack)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MetaStack)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MirrorGpencilModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MirrorGpencilModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(MirrorGpencilModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MirrorGpencilModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MirrorModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MirrorModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(MirrorModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MirrorModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(ModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ModifierViewerPathElem":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ModifierViewerPathElem, blk.Hdr.Count)
				for i := range bodies {
					body := new(ModifierViewerPathElem)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ModifierViewerPathElem)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MovieClip":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MovieClip, blk.Hdr.Count)
				for i := range bodies {
					body := new(MovieClip)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MovieClip)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MovieClipProxy":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MovieClipProxy, blk.Hdr.Count)
				for i := range bodies {
					body := new(MovieClipProxy)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MovieClipProxy)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MovieClipScopes":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MovieClipScopes, blk.Hdr.Count)
				for i := range bodies {
					body := new(MovieClipScopes)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MovieClipScopes)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MovieClipUser":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MovieClipUser, blk.Hdr.Count)
				for i := range bodies {
					body := new(MovieClipUser)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MovieClipUser)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MovieClip_Runtime":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MovieClip_Runtime, blk.Hdr.Count)
				for i := range bodies {
					body := new(MovieClip_Runtime)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MovieClip_Runtime)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MovieClip_RuntimeGPUTexture":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MovieClip_RuntimeGPUTexture, blk.Hdr.Count)
				for i := range bodies {
					body := new(MovieClip_RuntimeGPUTexture)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MovieClip_RuntimeGPUTexture)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MovieReconstructedCamera":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MovieReconstructedCamera, blk.Hdr.Count)
				for i := range bodies {
					body := new(MovieReconstructedCamera)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MovieReconstructedCamera)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MovieTracking":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MovieTracking, blk.Hdr.Count)
				for i := range bodies {
					body := new(MovieTracking)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MovieTracking)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MovieTrackingCamera":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MovieTrackingCamera, blk.Hdr.Count)
				for i := range bodies {
					body := new(MovieTrackingCamera)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MovieTrackingCamera)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MovieTrackingDopesheet":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MovieTrackingDopesheet, blk.Hdr.Count)
				for i := range bodies {
					body := new(MovieTrackingDopesheet)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MovieTrackingDopesheet)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MovieTrackingDopesheetChannel":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MovieTrackingDopesheetChannel, blk.Hdr.Count)
				for i := range bodies {
					body := new(MovieTrackingDopesheetChannel)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MovieTrackingDopesheetChannel)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MovieTrackingDopesheetCoverageSegment":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MovieTrackingDopesheetCoverageSegment, blk.Hdr.Count)
				for i := range bodies {
					body := new(MovieTrackingDopesheetCoverageSegment)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MovieTrackingDopesheetCoverageSegment)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MovieTrackingMarker":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MovieTrackingMarker, blk.Hdr.Count)
				for i := range bodies {
					body := new(MovieTrackingMarker)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MovieTrackingMarker)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MovieTrackingObject":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MovieTrackingObject, blk.Hdr.Count)
				for i := range bodies {
					body := new(MovieTrackingObject)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MovieTrackingObject)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MovieTrackingPlaneMarker":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MovieTrackingPlaneMarker, blk.Hdr.Count)
				for i := range bodies {
					body := new(MovieTrackingPlaneMarker)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MovieTrackingPlaneMarker)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MovieTrackingPlaneTrack":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MovieTrackingPlaneTrack, blk.Hdr.Count)
				for i := range bodies {
					body := new(MovieTrackingPlaneTrack)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MovieTrackingPlaneTrack)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MovieTrackingReconstruction":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MovieTrackingReconstruction, blk.Hdr.Count)
				for i := range bodies {
					body := new(MovieTrackingReconstruction)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MovieTrackingReconstruction)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MovieTrackingSettings":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MovieTrackingSettings, blk.Hdr.Count)
				for i := range bodies {
					body := new(MovieTrackingSettings)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MovieTrackingSettings)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MovieTrackingStabilization":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MovieTrackingStabilization, blk.Hdr.Count)
				for i := range bodies {
					body := new(MovieTrackingStabilization)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MovieTrackingStabilization)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MovieTrackingStats":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MovieTrackingStats, blk.Hdr.Count)
				for i := range bodies {
					body := new(MovieTrackingStats)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MovieTrackingStats)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MovieTrackingTrack":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MovieTrackingTrack, blk.Hdr.Count)
				for i := range bodies {
					body := new(MovieTrackingTrack)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MovieTrackingTrack)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MultiplyGpencilModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MultiplyGpencilModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(MultiplyGpencilModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MultiplyGpencilModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "MultiresModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*MultiresModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(MultiresModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(MultiresModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NlaStrip":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NlaStrip, blk.Hdr.Count)
				for i := range bodies {
					body := new(NlaStrip)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NlaStrip)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NlaTrack":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NlaTrack, blk.Hdr.Count)
				for i := range bodies {
					body := new(NlaTrack)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NlaTrack)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeAccumulateField":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeAccumulateField, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeAccumulateField)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeAccumulateField)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeAntiAliasingData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeAntiAliasingData, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeAntiAliasingData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeAntiAliasingData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeBilateralBlurData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeBilateralBlurData, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeBilateralBlurData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeBilateralBlurData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeBlurData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeBlurData, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeBlurData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeBlurData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeBokehImage":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeBokehImage, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeBokehImage)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeBokehImage)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeBoxMask":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeBoxMask, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeBoxMask)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeBoxMask)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeCMPCombSepColor":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeCMPCombSepColor, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeCMPCombSepColor)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeCMPCombSepColor)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeChroma":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeChroma, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeChroma)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeChroma)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeColorBalance":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeColorBalance, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeColorBalance)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeColorBalance)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeColorCorrection":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeColorCorrection, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeColorCorrection)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeColorCorrection)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeColorspill":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeColorspill, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeColorspill)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeColorspill)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeCombSepColor":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeCombSepColor, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeCombSepColor)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeCombSepColor)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeConvertColorSpace":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeConvertColorSpace, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeConvertColorSpace)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeConvertColorSpace)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeCryptomatte":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeCryptomatte, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeCryptomatte)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeCryptomatte)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeCryptomatte_Runtime":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeCryptomatte_Runtime, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeCryptomatte_Runtime)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeCryptomatte_Runtime)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeDBlurData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeDBlurData, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeDBlurData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeDBlurData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeDefocus":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeDefocus, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeDefocus)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeDefocus)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeDenoise":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeDenoise, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeDenoise)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeDenoise)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeDilateErode":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeDilateErode, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeDilateErode)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeDilateErode)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeEllipseMask":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeEllipseMask, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeEllipseMask)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeEllipseMask)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeFrame":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeFrame, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeFrame)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeFrame)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeFunctionCompare":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeFunctionCompare, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeFunctionCompare)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeFunctionCompare)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeGeometryAttributeCapture":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeGeometryAttributeCapture, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeGeometryAttributeCapture)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeGeometryAttributeCapture)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeGeometryCollectionInfo":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeGeometryCollectionInfo, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeGeometryCollectionInfo)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeGeometryCollectionInfo)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeGeometryCurveFill":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeGeometryCurveFill, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeGeometryCurveFill)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeGeometryCurveFill)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeGeometryCurveFillet":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeGeometryCurveFillet, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeGeometryCurveFillet)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeGeometryCurveFillet)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeGeometryCurvePrimitiveArc":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeGeometryCurvePrimitiveArc, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeGeometryCurvePrimitiveArc)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeGeometryCurvePrimitiveArc)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeGeometryCurvePrimitiveBezierSegment":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeGeometryCurvePrimitiveBezierSegment, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeGeometryCurvePrimitiveBezierSegment)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeGeometryCurvePrimitiveBezierSegment)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeGeometryCurvePrimitiveCircle":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeGeometryCurvePrimitiveCircle, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeGeometryCurvePrimitiveCircle)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeGeometryCurvePrimitiveCircle)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeGeometryCurvePrimitiveLine":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeGeometryCurvePrimitiveLine, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeGeometryCurvePrimitiveLine)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeGeometryCurvePrimitiveLine)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeGeometryCurvePrimitiveQuad":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeGeometryCurvePrimitiveQuad, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeGeometryCurvePrimitiveQuad)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeGeometryCurvePrimitiveQuad)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeGeometryCurveResample":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeGeometryCurveResample, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeGeometryCurveResample)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeGeometryCurveResample)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeGeometryCurveSample":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeGeometryCurveSample, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeGeometryCurveSample)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeGeometryCurveSample)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeGeometryCurveSelectHandles":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeGeometryCurveSelectHandles, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeGeometryCurveSelectHandles)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeGeometryCurveSelectHandles)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeGeometryCurveSetHandles":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeGeometryCurveSetHandles, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeGeometryCurveSetHandles)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeGeometryCurveSetHandles)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeGeometryCurveSplineType":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeGeometryCurveSplineType, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeGeometryCurveSplineType)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeGeometryCurveSplineType)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeGeometryCurveToPoints":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeGeometryCurveToPoints, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeGeometryCurveToPoints)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeGeometryCurveToPoints)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeGeometryCurveTrim":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeGeometryCurveTrim, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeGeometryCurveTrim)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeGeometryCurveTrim)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeGeometryDeleteGeometry":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeGeometryDeleteGeometry, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeGeometryDeleteGeometry)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeGeometryDeleteGeometry)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeGeometryDistributePointsInVolume":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeGeometryDistributePointsInVolume, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeGeometryDistributePointsInVolume)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeGeometryDistributePointsInVolume)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeGeometryDuplicateElements":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeGeometryDuplicateElements, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeGeometryDuplicateElements)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeGeometryDuplicateElements)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeGeometryExtrudeMesh":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeGeometryExtrudeMesh, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeGeometryExtrudeMesh)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeGeometryExtrudeMesh)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeGeometryImageTexture":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeGeometryImageTexture, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeGeometryImageTexture)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeGeometryImageTexture)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeGeometryInputNamedAttribute":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeGeometryInputNamedAttribute, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeGeometryInputNamedAttribute)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeGeometryInputNamedAttribute)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeGeometryMergeByDistance":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeGeometryMergeByDistance, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeGeometryMergeByDistance)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeGeometryMergeByDistance)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeGeometryMeshCircle":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeGeometryMeshCircle, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeGeometryMeshCircle)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeGeometryMeshCircle)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeGeometryMeshCone":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeGeometryMeshCone, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeGeometryMeshCone)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeGeometryMeshCone)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeGeometryMeshCylinder":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeGeometryMeshCylinder, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeGeometryMeshCylinder)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeGeometryMeshCylinder)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeGeometryMeshLine":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeGeometryMeshLine, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeGeometryMeshLine)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeGeometryMeshLine)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeGeometryMeshToPoints":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeGeometryMeshToPoints, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeGeometryMeshToPoints)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeGeometryMeshToPoints)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeGeometryMeshToVolume":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeGeometryMeshToVolume, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeGeometryMeshToVolume)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeGeometryMeshToVolume)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeGeometryObjectInfo":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeGeometryObjectInfo, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeGeometryObjectInfo)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeGeometryObjectInfo)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeGeometryPointsToVolume":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeGeometryPointsToVolume, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeGeometryPointsToVolume)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeGeometryPointsToVolume)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeGeometryProximity":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeGeometryProximity, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeGeometryProximity)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeGeometryProximity)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeGeometryRaycast":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeGeometryRaycast, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeGeometryRaycast)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeGeometryRaycast)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeGeometrySampleIndex":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeGeometrySampleIndex, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeGeometrySampleIndex)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeGeometrySampleIndex)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeGeometrySeparateGeometry":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeGeometrySeparateGeometry, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeGeometrySeparateGeometry)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeGeometrySeparateGeometry)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeGeometrySetCurveHandlePositions":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeGeometrySetCurveHandlePositions, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeGeometrySetCurveHandlePositions)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeGeometrySetCurveHandlePositions)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeGeometryStoreNamedAttribute":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeGeometryStoreNamedAttribute, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeGeometryStoreNamedAttribute)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeGeometryStoreNamedAttribute)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeGeometryStringToCurves":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeGeometryStringToCurves, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeGeometryStringToCurves)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeGeometryStringToCurves)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeGeometrySubdivisionSurface":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeGeometrySubdivisionSurface, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeGeometrySubdivisionSurface)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeGeometrySubdivisionSurface)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeGeometryTransferAttribute":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeGeometryTransferAttribute, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeGeometryTransferAttribute)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeGeometryTransferAttribute)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeGeometryUVUnwrap":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeGeometryUVUnwrap, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeGeometryUVUnwrap)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeGeometryUVUnwrap)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeGeometryViewer":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeGeometryViewer, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeGeometryViewer)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeGeometryViewer)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeGeometryVolumeToMesh":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeGeometryVolumeToMesh, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeGeometryVolumeToMesh)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeGeometryVolumeToMesh)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeGlare":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeGlare, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeGlare)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeGlare)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeHueSat":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeHueSat, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeHueSat)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeHueSat)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeImageAnim":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeImageAnim, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeImageAnim)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeImageAnim)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeImageFile":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeImageFile, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeImageFile)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeImageFile)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeImageLayer":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeImageLayer, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeImageLayer)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeImageLayer)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeImageMultiFile":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeImageMultiFile, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeImageMultiFile)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeImageMultiFile)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeImageMultiFileSocket":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeImageMultiFileSocket, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeImageMultiFileSocket)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeImageMultiFileSocket)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeInputBool":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeInputBool, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeInputBool)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeInputBool)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeInputColor":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeInputColor, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeInputColor)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeInputColor)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeInputInt":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeInputInt, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeInputInt)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeInputInt)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeInputString":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeInputString, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeInputString)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeInputString)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeInputVector":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeInputVector, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeInputVector)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeInputVector)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeKeyingData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeKeyingData, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeKeyingData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeKeyingData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeKeyingScreenData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeKeyingScreenData, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeKeyingScreenData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeKeyingScreenData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeLensDist":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeLensDist, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeLensDist)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeLensDist)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeMapRange":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeMapRange, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeMapRange)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeMapRange)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeMask":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeMask, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeMask)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeMask)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodePlaneTrackDeformData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodePlaneTrackDeformData, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodePlaneTrackDeformData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodePlaneTrackDeformData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeRandomValue":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeRandomValue, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeRandomValue)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeRandomValue)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeScriptDict":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeScriptDict, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeScriptDict)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeScriptDict)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeSetAlpha":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeSetAlpha, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeSetAlpha)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeSetAlpha)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeShaderAttribute":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeShaderAttribute, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeShaderAttribute)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeShaderAttribute)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeShaderMix":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeShaderMix, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeShaderMix)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeShaderMix)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeShaderNormalMap":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeShaderNormalMap, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeShaderNormalMap)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeShaderNormalMap)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeShaderOutputAOV":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeShaderOutputAOV, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeShaderOutputAOV)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeShaderOutputAOV)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeShaderPrincipled":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeShaderPrincipled, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeShaderPrincipled)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeShaderPrincipled)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeShaderScript":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeShaderScript, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeShaderScript)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeShaderScript)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeShaderTangent":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeShaderTangent, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeShaderTangent)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeShaderTangent)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeShaderTexIES":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeShaderTexIES, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeShaderTexIES)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeShaderTexIES)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeShaderTexPointDensity":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeShaderTexPointDensity, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeShaderTexPointDensity)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeShaderTexPointDensity)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeShaderUVMap":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeShaderUVMap, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeShaderUVMap)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeShaderUVMap)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeShaderVectTransform":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeShaderVectTransform, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeShaderVectTransform)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeShaderVectTransform)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeShaderVertexColor":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeShaderVertexColor, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeShaderVertexColor)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeShaderVertexColor)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeSunBeams":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeSunBeams, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeSunBeams)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeSunBeams)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeSwitch":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeSwitch, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeSwitch)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeSwitch)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeTexBase":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeTexBase, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeTexBase)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeTexBase)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeTexBrick":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeTexBrick, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeTexBrick)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeTexBrick)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeTexChecker":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeTexChecker, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeTexChecker)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeTexChecker)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeTexEnvironment":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeTexEnvironment, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeTexEnvironment)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeTexEnvironment)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeTexGradient":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeTexGradient, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeTexGradient)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeTexGradient)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeTexImage":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeTexImage, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeTexImage)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeTexImage)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeTexMagic":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeTexMagic, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeTexMagic)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeTexMagic)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeTexMusgrave":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeTexMusgrave, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeTexMusgrave)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeTexMusgrave)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeTexNoise":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeTexNoise, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeTexNoise)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeTexNoise)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeTexSky":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeTexSky, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeTexSky)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeTexSky)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeTexVoronoi":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeTexVoronoi, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeTexVoronoi)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeTexVoronoi)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeTexWave":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeTexWave, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeTexWave)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeTexWave)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeTonemap":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeTonemap, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeTonemap)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeTonemap)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeTrackPosData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeTrackPosData, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeTrackPosData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeTrackPosData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeTranslateData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeTranslateData, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeTranslateData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeTranslateData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeTwoFloats":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeTwoFloats, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeTwoFloats)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeTwoFloats)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeTwoXYs":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeTwoXYs, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeTwoXYs)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeTwoXYs)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeVertexCol":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeVertexCol, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeVertexCol)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeVertexCol)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodeViewerPathElem":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodeViewerPathElem, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodeViewerPathElem)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodeViewerPathElem)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodesModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodesModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodesModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodesModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NodesModifierSettings":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NodesModifierSettings, blk.Hdr.Count)
				for i := range bodies {
					body := new(NodesModifierSettings)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NodesModifierSettings)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NoiseGpencilModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NoiseGpencilModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(NoiseGpencilModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NoiseGpencilModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "NormalEditModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*NormalEditModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(NormalEditModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(NormalEditModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "Nurb":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Nurb, blk.Hdr.Count)
				for i := range bodies {
					body := new(Nurb)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Nurb)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ObHook":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ObHook, blk.Hdr.Count)
				for i := range bodies {
					body := new(ObHook)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ObHook)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "Object":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Object, blk.Hdr.Count)
				for i := range bodies {
					body := new(Object)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Object)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ObjectLineArt":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ObjectLineArt, blk.Hdr.Count)
				for i := range bodies {
					body := new(ObjectLineArt)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ObjectLineArt)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "Object_Runtime":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Object_Runtime, blk.Hdr.Count)
				for i := range bodies {
					body := new(Object_Runtime)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Object_Runtime)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "OceanModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*OceanModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(OceanModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(OceanModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "OffsetGpencilModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*OffsetGpencilModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(OffsetGpencilModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(OffsetGpencilModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "OpacityGpencilModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*OpacityGpencilModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(OpacityGpencilModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(OpacityGpencilModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "OutlineGpencilModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*OutlineGpencilModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(OutlineGpencilModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(OutlineGpencilModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "PTCacheExtra":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*PTCacheExtra, blk.Hdr.Count)
				for i := range bodies {
					body := new(PTCacheExtra)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(PTCacheExtra)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "PTCacheMem":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*PTCacheMem, blk.Hdr.Count)
				for i := range bodies {
					body := new(PTCacheMem)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(PTCacheMem)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "PackedFile":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*PackedFile, blk.Hdr.Count)
				for i := range bodies {
					body := new(PackedFile)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(PackedFile)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "Paint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Paint, blk.Hdr.Count)
				for i := range bodies {
					body := new(Paint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Paint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "PaintCurve":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*PaintCurve, blk.Hdr.Count)
				for i := range bodies {
					body := new(PaintCurve)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(PaintCurve)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "PaintCurvePoint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*PaintCurvePoint, blk.Hdr.Count)
				for i := range bodies {
					body := new(PaintCurvePoint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(PaintCurvePoint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "PaintModeSettings":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*PaintModeSettings, blk.Hdr.Count)
				for i := range bodies {
					body := new(PaintModeSettings)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(PaintModeSettings)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "PaintToolSlot":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*PaintToolSlot, blk.Hdr.Count)
				for i := range bodies {
					body := new(PaintToolSlot)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(PaintToolSlot)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "Paint_Runtime":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Paint_Runtime, blk.Hdr.Count)
				for i := range bodies {
					body := new(Paint_Runtime)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Paint_Runtime)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "Palette":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Palette, blk.Hdr.Count)
				for i := range bodies {
					body := new(Palette)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Palette)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "PaletteColor":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*PaletteColor, blk.Hdr.Count)
				for i := range bodies {
					body := new(PaletteColor)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(PaletteColor)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "Panel":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Panel, blk.Hdr.Count)
				for i := range bodies {
					body := new(Panel)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Panel)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "PanelCategoryStack":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*PanelCategoryStack, blk.Hdr.Count)
				for i := range bodies {
					body := new(PanelCategoryStack)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(PanelCategoryStack)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "Panel_Runtime":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Panel_Runtime, blk.Hdr.Count)
				for i := range bodies {
					body := new(Panel_Runtime)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Panel_Runtime)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "PartDeflect":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*PartDeflect, blk.Hdr.Count)
				for i := range bodies {
					body := new(PartDeflect)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(PartDeflect)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "PartEff":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*PartEff, blk.Hdr.Count)
				for i := range bodies {
					body := new(PartEff)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(PartEff)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ParticleBrushData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ParticleBrushData, blk.Hdr.Count)
				for i := range bodies {
					body := new(ParticleBrushData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ParticleBrushData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ParticleData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ParticleData, blk.Hdr.Count)
				for i := range bodies {
					body := new(ParticleData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ParticleData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ParticleDupliWeight":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ParticleDupliWeight, blk.Hdr.Count)
				for i := range bodies {
					body := new(ParticleDupliWeight)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ParticleDupliWeight)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ParticleEditSettings":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ParticleEditSettings, blk.Hdr.Count)
				for i := range bodies {
					body := new(ParticleEditSettings)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ParticleEditSettings)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ParticleInstanceModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ParticleInstanceModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(ParticleInstanceModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ParticleInstanceModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ParticleKey":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ParticleKey, blk.Hdr.Count)
				for i := range bodies {
					body := new(ParticleKey)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ParticleKey)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ParticleSettings":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ParticleSettings, blk.Hdr.Count)
				for i := range bodies {
					body := new(ParticleSettings)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ParticleSettings)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ParticleSpring":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ParticleSpring, blk.Hdr.Count)
				for i := range bodies {
					body := new(ParticleSpring)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ParticleSpring)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ParticleSystem":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ParticleSystem, blk.Hdr.Count)
				for i := range bodies {
					body := new(ParticleSystem)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ParticleSystem)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ParticleSystemModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ParticleSystemModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(ParticleSystemModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ParticleSystemModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ParticleTarget":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ParticleTarget, blk.Hdr.Count)
				for i := range bodies {
					body := new(ParticleTarget)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ParticleTarget)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "PhysicsSettings":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*PhysicsSettings, blk.Hdr.Count)
				for i := range bodies {
					body := new(PhysicsSettings)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(PhysicsSettings)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "PixelShaderFxData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*PixelShaderFxData, blk.Hdr.Count)
				for i := range bodies {
					body := new(PixelShaderFxData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(PixelShaderFxData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "PointCache":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*PointCache, blk.Hdr.Count)
				for i := range bodies {
					body := new(PointCache)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(PointCache)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "PointCloud":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*PointCloud, blk.Hdr.Count)
				for i := range bodies {
					body := new(PointCloud)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(PointCloud)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "PointDensity":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*PointDensity, blk.Hdr.Count)
				for i := range bodies {
					body := new(PointDensity)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(PointDensity)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "PreviewImage":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*PreviewImage, blk.Hdr.Count)
				for i := range bodies {
					body := new(PreviewImage)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(PreviewImage)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "RegionView3D":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*RegionView3D, blk.Hdr.Count)
				for i := range bodies {
					body := new(RegionView3D)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(RegionView3D)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "RemeshModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*RemeshModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(RemeshModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(RemeshModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "RenderData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*RenderData, blk.Hdr.Count)
				for i := range bodies {
					body := new(RenderData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(RenderData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "RenderProfile":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*RenderProfile, blk.Hdr.Count)
				for i := range bodies {
					body := new(RenderProfile)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(RenderProfile)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "RenderSlot":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*RenderSlot, blk.Hdr.Count)
				for i := range bodies {
					body := new(RenderSlot)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(RenderSlot)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ReportList":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ReportList, blk.Hdr.Count)
				for i := range bodies {
					body := new(ReportList)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ReportList)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "RigidBodyCon":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*RigidBodyCon, blk.Hdr.Count)
				for i := range bodies {
					body := new(RigidBodyCon)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(RigidBodyCon)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "RigidBodyOb":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*RigidBodyOb, blk.Hdr.Count)
				for i := range bodies {
					body := new(RigidBodyOb)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(RigidBodyOb)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "RigidBodyWorld":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*RigidBodyWorld, blk.Hdr.Count)
				for i := range bodies {
					body := new(RigidBodyWorld)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(RigidBodyWorld)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "RigidBodyWorld_Shared":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*RigidBodyWorld_Shared, blk.Hdr.Count)
				for i := range bodies {
					body := new(RigidBodyWorld_Shared)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(RigidBodyWorld_Shared)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "RimShaderFxData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*RimShaderFxData, blk.Hdr.Count)
				for i := range bodies {
					body := new(RimShaderFxData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(RimShaderFxData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SBVertex":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SBVertex, blk.Hdr.Count)
				for i := range bodies {
					body := new(SBVertex)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SBVertex)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SDefBind":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SDefBind, blk.Hdr.Count)
				for i := range bodies {
					body := new(SDefBind)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SDefBind)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SDefVert":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SDefVert, blk.Hdr.Count)
				for i := range bodies {
					body := new(SDefVert)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SDefVert)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SPHFluidSettings":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SPHFluidSettings, blk.Hdr.Count)
				for i := range bodies {
					body := new(SPHFluidSettings)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SPHFluidSettings)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "Scene":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Scene, blk.Hdr.Count)
				for i := range bodies {
					body := new(Scene)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Scene)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SceneCollection":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SceneCollection, blk.Hdr.Count)
				for i := range bodies {
					body := new(SceneCollection)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SceneCollection)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SceneDisplay":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SceneDisplay, blk.Hdr.Count)
				for i := range bodies {
					body := new(SceneDisplay)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SceneDisplay)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SceneEEVEE":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SceneEEVEE, blk.Hdr.Count)
				for i := range bodies {
					body := new(SceneEEVEE)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SceneEEVEE)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SceneGpencil":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SceneGpencil, blk.Hdr.Count)
				for i := range bodies {
					body := new(SceneGpencil)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SceneGpencil)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SceneRenderLayer":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SceneRenderLayer, blk.Hdr.Count)
				for i := range bodies {
					body := new(SceneRenderLayer)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SceneRenderLayer)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SceneRenderView":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SceneRenderView, blk.Hdr.Count)
				for i := range bodies {
					body := new(SceneRenderView)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SceneRenderView)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "Scopes":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Scopes, blk.Hdr.Count)
				for i := range bodies {
					body := new(Scopes)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Scopes)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ScrArea":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ScrArea, blk.Hdr.Count)
				for i := range bodies {
					body := new(ScrArea)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ScrArea)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ScrAreaMap":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ScrAreaMap, blk.Hdr.Count)
				for i := range bodies {
					body := new(ScrAreaMap)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ScrAreaMap)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ScrArea_Runtime":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ScrArea_Runtime, blk.Hdr.Count)
				for i := range bodies {
					body := new(ScrArea_Runtime)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ScrArea_Runtime)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ScrEdge":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ScrEdge, blk.Hdr.Count)
				for i := range bodies {
					body := new(ScrEdge)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ScrEdge)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ScrGlobalAreaData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ScrGlobalAreaData, blk.Hdr.Count)
				for i := range bodies {
					body := new(ScrGlobalAreaData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ScrGlobalAreaData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ScrVert":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ScrVert, blk.Hdr.Count)
				for i := range bodies {
					body := new(ScrVert)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ScrVert)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ScrewModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ScrewModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(ScrewModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ScrewModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "Script":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Script, blk.Hdr.Count)
				for i := range bodies {
					body := new(Script)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Script)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "Sculpt":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Sculpt, blk.Hdr.Count)
				for i := range bodies {
					body := new(Sculpt)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Sculpt)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SeqTimelineChannel":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SeqTimelineChannel, blk.Hdr.Count)
				for i := range bodies {
					body := new(SeqTimelineChannel)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SeqTimelineChannel)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "Sequence":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Sequence, blk.Hdr.Count)
				for i := range bodies {
					body := new(Sequence)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Sequence)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SequenceModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SequenceModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(SequenceModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SequenceModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SequenceRuntime":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SequenceRuntime, blk.Hdr.Count)
				for i := range bodies {
					body := new(SequenceRuntime)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SequenceRuntime)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SequencerMaskModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SequencerMaskModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(SequencerMaskModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SequencerMaskModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SequencerPreviewOverlay":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SequencerPreviewOverlay, blk.Hdr.Count)
				for i := range bodies {
					body := new(SequencerPreviewOverlay)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SequencerPreviewOverlay)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SequencerScopes":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SequencerScopes, blk.Hdr.Count)
				for i := range bodies {
					body := new(SequencerScopes)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SequencerScopes)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SequencerTimelineOverlay":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SequencerTimelineOverlay, blk.Hdr.Count)
				for i := range bodies {
					body := new(SequencerTimelineOverlay)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SequencerTimelineOverlay)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SequencerTonemapModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SequencerTonemapModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(SequencerTonemapModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SequencerTonemapModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SequencerToolSettings":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SequencerToolSettings, blk.Hdr.Count)
				for i := range bodies {
					body := new(SequencerToolSettings)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SequencerToolSettings)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SessionUUID":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SessionUUID, blk.Hdr.Count)
				for i := range bodies {
					body := new(SessionUUID)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SessionUUID)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ShaderFxData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ShaderFxData, blk.Hdr.Count)
				for i := range bodies {
					body := new(ShaderFxData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ShaderFxData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ShaderFxData_Runtime":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ShaderFxData_Runtime, blk.Hdr.Count)
				for i := range bodies {
					body := new(ShaderFxData_Runtime)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ShaderFxData_Runtime)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ShadowShaderFxData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ShadowShaderFxData, blk.Hdr.Count)
				for i := range bodies {
					body := new(ShadowShaderFxData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ShadowShaderFxData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ShapeKeyModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ShapeKeyModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(ShapeKeyModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ShapeKeyModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ShrinkwrapGpencilModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ShrinkwrapGpencilModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(ShrinkwrapGpencilModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ShrinkwrapGpencilModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ShrinkwrapModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ShrinkwrapModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(ShrinkwrapModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ShrinkwrapModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SimpleDeformModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SimpleDeformModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(SimpleDeformModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SimpleDeformModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SimplifyGpencilModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SimplifyGpencilModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(SimplifyGpencilModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SimplifyGpencilModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "Simulation":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Simulation, blk.Hdr.Count)
				for i := range bodies {
					body := new(Simulation)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Simulation)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SkinModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SkinModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(SkinModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SkinModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SmokeModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SmokeModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(SmokeModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SmokeModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SmoothGpencilModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SmoothGpencilModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(SmoothGpencilModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SmoothGpencilModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SmoothModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SmoothModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(SmoothModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SmoothModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SoftBody":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SoftBody, blk.Hdr.Count)
				for i := range bodies {
					body := new(SoftBody)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SoftBody)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SoftBody_Shared":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SoftBody_Shared, blk.Hdr.Count)
				for i := range bodies {
					body := new(SoftBody_Shared)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SoftBody_Shared)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SoftbodyModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SoftbodyModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(SoftbodyModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SoftbodyModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SolidColorVars":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SolidColorVars, blk.Hdr.Count)
				for i := range bodies {
					body := new(SolidColorVars)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SolidColorVars)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SolidLight":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SolidLight, blk.Hdr.Count)
				for i := range bodies {
					body := new(SolidLight)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SolidLight)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SolidifyModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SolidifyModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(SolidifyModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SolidifyModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SpaceAction":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SpaceAction, blk.Hdr.Count)
				for i := range bodies {
					body := new(SpaceAction)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SpaceAction)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SpaceAction_Runtime":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SpaceAction_Runtime, blk.Hdr.Count)
				for i := range bodies {
					body := new(SpaceAction_Runtime)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SpaceAction_Runtime)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SpaceButs":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SpaceButs, blk.Hdr.Count)
				for i := range bodies {
					body := new(SpaceButs)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SpaceButs)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SpaceClip":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SpaceClip, blk.Hdr.Count)
				for i := range bodies {
					body := new(SpaceClip)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SpaceClip)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SpaceConsole":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SpaceConsole, blk.Hdr.Count)
				for i := range bodies {
					body := new(SpaceConsole)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SpaceConsole)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SpaceFile":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SpaceFile, blk.Hdr.Count)
				for i := range bodies {
					body := new(SpaceFile)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SpaceFile)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SpaceGraph_Runtime":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SpaceGraph_Runtime, blk.Hdr.Count)
				for i := range bodies {
					body := new(SpaceGraph_Runtime)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SpaceGraph_Runtime)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SpaceImage":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SpaceImage, blk.Hdr.Count)
				for i := range bodies {
					body := new(SpaceImage)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SpaceImage)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SpaceImageOverlay":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SpaceImageOverlay, blk.Hdr.Count)
				for i := range bodies {
					body := new(SpaceImageOverlay)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SpaceImageOverlay)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SpaceInfo":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SpaceInfo, blk.Hdr.Count)
				for i := range bodies {
					body := new(SpaceInfo)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SpaceInfo)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SpaceIpo":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SpaceIpo, blk.Hdr.Count)
				for i := range bodies {
					body := new(SpaceIpo)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SpaceIpo)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SpaceLink":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SpaceLink, blk.Hdr.Count)
				for i := range bodies {
					body := new(SpaceLink)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SpaceLink)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SpaceNla":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SpaceNla, blk.Hdr.Count)
				for i := range bodies {
					body := new(SpaceNla)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SpaceNla)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SpaceNode":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SpaceNode, blk.Hdr.Count)
				for i := range bodies {
					body := new(SpaceNode)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SpaceNode)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SpaceNodeOverlay":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SpaceNodeOverlay, blk.Hdr.Count)
				for i := range bodies {
					body := new(SpaceNodeOverlay)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SpaceNodeOverlay)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SpaceOops":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SpaceOops, blk.Hdr.Count)
				for i := range bodies {
					body := new(SpaceOops)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SpaceOops)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SpaceScript":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SpaceScript, blk.Hdr.Count)
				for i := range bodies {
					body := new(SpaceScript)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SpaceScript)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SpaceSeq":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SpaceSeq, blk.Hdr.Count)
				for i := range bodies {
					body := new(SpaceSeq)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SpaceSeq)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SpaceSeqRuntime":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SpaceSeqRuntime, blk.Hdr.Count)
				for i := range bodies {
					body := new(SpaceSeqRuntime)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SpaceSeqRuntime)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SpaceSpreadsheet":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SpaceSpreadsheet, blk.Hdr.Count)
				for i := range bodies {
					body := new(SpaceSpreadsheet)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SpaceSpreadsheet)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SpaceStatusBar":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SpaceStatusBar, blk.Hdr.Count)
				for i := range bodies {
					body := new(SpaceStatusBar)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SpaceStatusBar)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SpaceText":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SpaceText, blk.Hdr.Count)
				for i := range bodies {
					body := new(SpaceText)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SpaceText)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SpaceText_Runtime":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SpaceText_Runtime, blk.Hdr.Count)
				for i := range bodies {
					body := new(SpaceText_Runtime)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SpaceText_Runtime)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SpaceTopBar":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SpaceTopBar, blk.Hdr.Count)
				for i := range bodies {
					body := new(SpaceTopBar)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SpaceTopBar)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SpaceUserPref":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SpaceUserPref, blk.Hdr.Count)
				for i := range bodies {
					body := new(SpaceUserPref)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SpaceUserPref)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "Speaker":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Speaker, blk.Hdr.Count)
				for i := range bodies {
					body := new(Speaker)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Speaker)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SpeedControlVars":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SpeedControlVars, blk.Hdr.Count)
				for i := range bodies {
					body := new(SpeedControlVars)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SpeedControlVars)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SpreadsheetColumn":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SpreadsheetColumn, blk.Hdr.Count)
				for i := range bodies {
					body := new(SpreadsheetColumn)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SpreadsheetColumn)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SpreadsheetColumnID":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SpreadsheetColumnID, blk.Hdr.Count)
				for i := range bodies {
					body := new(SpreadsheetColumnID)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SpreadsheetColumnID)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SpreadsheetRowFilter":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SpreadsheetRowFilter, blk.Hdr.Count)
				for i := range bodies {
					body := new(SpreadsheetRowFilter)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SpreadsheetRowFilter)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "Stereo3dFormat":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Stereo3dFormat, blk.Hdr.Count)
				for i := range bodies {
					body := new(Stereo3dFormat)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Stereo3dFormat)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "Strip":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Strip, blk.Hdr.Count)
				for i := range bodies {
					body := new(Strip)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Strip)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "StripAnim":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*StripAnim, blk.Hdr.Count)
				for i := range bodies {
					body := new(StripAnim)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(StripAnim)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "StripColorBalance":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*StripColorBalance, blk.Hdr.Count)
				for i := range bodies {
					body := new(StripColorBalance)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(StripColorBalance)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "StripCrop":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*StripCrop, blk.Hdr.Count)
				for i := range bodies {
					body := new(StripCrop)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(StripCrop)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "StripElem":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*StripElem, blk.Hdr.Count)
				for i := range bodies {
					body := new(StripElem)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(StripElem)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "StripProxy":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*StripProxy, blk.Hdr.Count)
				for i := range bodies {
					body := new(StripProxy)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(StripProxy)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "StripTransform":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*StripTransform, blk.Hdr.Count)
				for i := range bodies {
					body := new(StripTransform)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(StripTransform)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SubdivGpencilModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SubdivGpencilModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(SubdivGpencilModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SubdivGpencilModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SubsurfModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SubsurfModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(SubsurfModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SubsurfModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SurfaceDeformModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SurfaceDeformModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(SurfaceDeformModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SurfaceDeformModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SurfaceModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SurfaceModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(SurfaceModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SurfaceModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SurfaceModifierData_Runtime":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SurfaceModifierData_Runtime, blk.Hdr.Count)
				for i := range bodies {
					body := new(SurfaceModifierData_Runtime)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SurfaceModifierData_Runtime)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "SwirlShaderFxData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*SwirlShaderFxData, blk.Hdr.Count)
				for i := range bodies {
					body := new(SwirlShaderFxData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(SwirlShaderFxData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "TFace":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*TFace, blk.Hdr.Count)
				for i := range bodies {
					body := new(TFace)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(TFace)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "Tex":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Tex, blk.Hdr.Count)
				for i := range bodies {
					body := new(Tex)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Tex)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "TexMapping":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*TexMapping, blk.Hdr.Count)
				for i := range bodies {
					body := new(TexMapping)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(TexMapping)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "TexNodeOutput":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*TexNodeOutput, blk.Hdr.Count)
				for i := range bodies {
					body := new(TexNodeOutput)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(TexNodeOutput)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "TexPaintSlot":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*TexPaintSlot, blk.Hdr.Count)
				for i := range bodies {
					body := new(TexPaintSlot)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(TexPaintSlot)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "Text":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Text, blk.Hdr.Count)
				for i := range bodies {
					body := new(Text)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Text)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "TextBox":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*TextBox, blk.Hdr.Count)
				for i := range bodies {
					body := new(TextBox)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(TextBox)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "TextLine":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*TextLine, blk.Hdr.Count)
				for i := range bodies {
					body := new(TextLine)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(TextLine)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "TextVars":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*TextVars, blk.Hdr.Count)
				for i := range bodies {
					body := new(TextVars)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(TextVars)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "TextureGpencilModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*TextureGpencilModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(TextureGpencilModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(TextureGpencilModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ThemeCollectionColor":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ThemeCollectionColor, blk.Hdr.Count)
				for i := range bodies {
					body := new(ThemeCollectionColor)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ThemeCollectionColor)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ThemeSpace":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ThemeSpace, blk.Hdr.Count)
				for i := range bodies {
					body := new(ThemeSpace)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ThemeSpace)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ThemeStripColor":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ThemeStripColor, blk.Hdr.Count)
				for i := range bodies {
					body := new(ThemeStripColor)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ThemeStripColor)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ThemeUI":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ThemeUI, blk.Hdr.Count)
				for i := range bodies {
					body := new(ThemeUI)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ThemeUI)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ThemeWireColor":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ThemeWireColor, blk.Hdr.Count)
				for i := range bodies {
					body := new(ThemeWireColor)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ThemeWireColor)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ThickGpencilModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ThickGpencilModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(ThickGpencilModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ThickGpencilModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "TimeGpencilModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*TimeGpencilModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(TimeGpencilModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(TimeGpencilModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "TimeGpencilModifierSegment":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*TimeGpencilModifierSegment, blk.Hdr.Count)
				for i := range bodies {
					body := new(TimeGpencilModifierSegment)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(TimeGpencilModifierSegment)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "TimeMarker":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*TimeMarker, blk.Hdr.Count)
				for i := range bodies {
					body := new(TimeMarker)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(TimeMarker)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "TintGpencilModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*TintGpencilModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(TintGpencilModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(TintGpencilModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ToolSettings":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ToolSettings, blk.Hdr.Count)
				for i := range bodies {
					body := new(ToolSettings)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ToolSettings)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "TransformOrientation":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*TransformOrientation, blk.Hdr.Count)
				for i := range bodies {
					body := new(TransformOrientation)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(TransformOrientation)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "TransformOrientationSlot":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*TransformOrientationSlot, blk.Hdr.Count)
				for i := range bodies {
					body := new(TransformOrientationSlot)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(TransformOrientationSlot)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "TransformVars":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*TransformVars, blk.Hdr.Count)
				for i := range bodies {
					body := new(TransformVars)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(TransformVars)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "TreeStore":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*TreeStore, blk.Hdr.Count)
				for i := range bodies {
					body := new(TreeStore)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(TreeStore)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "TreeStoreElem":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*TreeStoreElem, blk.Hdr.Count)
				for i := range bodies {
					body := new(TreeStoreElem)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(TreeStoreElem)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "TriangulateModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*TriangulateModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(TriangulateModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(TriangulateModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "UVProjectModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*UVProjectModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(UVProjectModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(UVProjectModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "UVWarpModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*UVWarpModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(UVWarpModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(UVWarpModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "UnifiedPaintSettings":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*UnifiedPaintSettings, blk.Hdr.Count)
				for i := range bodies {
					body := new(UnifiedPaintSettings)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(UnifiedPaintSettings)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "UnitSettings":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*UnitSettings, blk.Hdr.Count)
				for i := range bodies {
					body := new(UnitSettings)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(UnitSettings)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "UserDef":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*UserDef, blk.Hdr.Count)
				for i := range bodies {
					body := new(UserDef)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(UserDef)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "UserDef_Experimental":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*UserDef_Experimental, blk.Hdr.Count)
				for i := range bodies {
					body := new(UserDef_Experimental)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(UserDef_Experimental)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "UserDef_FileSpaceData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*UserDef_FileSpaceData, blk.Hdr.Count)
				for i := range bodies {
					body := new(UserDef_FileSpaceData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(UserDef_FileSpaceData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "UserDef_Runtime":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*UserDef_Runtime, blk.Hdr.Count)
				for i := range bodies {
					body := new(UserDef_Runtime)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(UserDef_Runtime)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "UserDef_SpaceData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*UserDef_SpaceData, blk.Hdr.Count)
				for i := range bodies {
					body := new(UserDef_SpaceData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(UserDef_SpaceData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "UvSculpt":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*UvSculpt, blk.Hdr.Count)
				for i := range bodies {
					body := new(UvSculpt)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(UvSculpt)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "VFont":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*VFont, blk.Hdr.Count)
				for i := range bodies {
					body := new(VFont)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(VFont)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "VPaint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*VPaint, blk.Hdr.Count)
				for i := range bodies {
					body := new(VPaint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(VPaint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "View2D":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*View2D, blk.Hdr.Count)
				for i := range bodies {
					body := new(View2D)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(View2D)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "View3D":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*View3D, blk.Hdr.Count)
				for i := range bodies {
					body := new(View3D)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(View3D)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "View3DCursor":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*View3DCursor, blk.Hdr.Count)
				for i := range bodies {
					body := new(View3DCursor)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(View3DCursor)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "View3DOverlay":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*View3DOverlay, blk.Hdr.Count)
				for i := range bodies {
					body := new(View3DOverlay)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(View3DOverlay)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "View3DShading":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*View3DShading, blk.Hdr.Count)
				for i := range bodies {
					body := new(View3DShading)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(View3DShading)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "View3D_Runtime":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*View3D_Runtime, blk.Hdr.Count)
				for i := range bodies {
					body := new(View3D_Runtime)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(View3D_Runtime)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ViewLayer":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ViewLayer, blk.Hdr.Count)
				for i := range bodies {
					body := new(ViewLayer)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ViewLayer)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ViewLayerAOV":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ViewLayerAOV, blk.Hdr.Count)
				for i := range bodies {
					body := new(ViewLayerAOV)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ViewLayerAOV)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ViewLayerEEVEE":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ViewLayerEEVEE, blk.Hdr.Count)
				for i := range bodies {
					body := new(ViewLayerEEVEE)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ViewLayerEEVEE)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ViewLayerEngineData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ViewLayerEngineData, blk.Hdr.Count)
				for i := range bodies {
					body := new(ViewLayerEngineData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ViewLayerEngineData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ViewLayerLightgroup":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ViewLayerLightgroup, blk.Hdr.Count)
				for i := range bodies {
					body := new(ViewLayerLightgroup)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ViewLayerLightgroup)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ViewerPath":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ViewerPath, blk.Hdr.Count)
				for i := range bodies {
					body := new(ViewerPath)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ViewerPath)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "ViewerPathElem":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*ViewerPathElem, blk.Hdr.Count)
				for i := range bodies {
					body := new(ViewerPathElem)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(ViewerPathElem)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "Volume":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Volume, blk.Hdr.Count)
				for i := range bodies {
					body := new(Volume)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Volume)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "VolumeDisplaceModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*VolumeDisplaceModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(VolumeDisplaceModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(VolumeDisplaceModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "VolumeDisplay":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*VolumeDisplay, blk.Hdr.Count)
				for i := range bodies {
					body := new(VolumeDisplay)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(VolumeDisplay)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "VolumeRender":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*VolumeRender, blk.Hdr.Count)
				for i := range bodies {
					body := new(VolumeRender)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(VolumeRender)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "VolumeToMeshModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*VolumeToMeshModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(VolumeToMeshModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(VolumeToMeshModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "Volume_Runtime":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Volume_Runtime, blk.Hdr.Count)
				for i := range bodies {
					body := new(Volume_Runtime)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Volume_Runtime)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "WalkNavigation":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*WalkNavigation, blk.Hdr.Count)
				for i := range bodies {
					body := new(WalkNavigation)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(WalkNavigation)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "WarpModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*WarpModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(WarpModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(WarpModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "WaveEff":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*WaveEff, blk.Hdr.Count)
				for i := range bodies {
					body := new(WaveEff)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(WaveEff)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "WaveModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*WaveModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(WaveModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(WaveModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "WaveShaderFxData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*WaveShaderFxData, blk.Hdr.Count)
				for i := range bodies {
					body := new(WaveShaderFxData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(WaveShaderFxData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "WeightAngleGpencilModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*WeightAngleGpencilModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(WeightAngleGpencilModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(WeightAngleGpencilModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "WeightProxGpencilModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*WeightProxGpencilModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(WeightProxGpencilModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(WeightProxGpencilModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "WeightVGEditModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*WeightVGEditModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(WeightVGEditModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(WeightVGEditModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "WeightVGMixModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*WeightVGMixModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(WeightVGMixModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(WeightVGMixModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "WeightVGProximityModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*WeightVGProximityModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(WeightVGProximityModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(WeightVGProximityModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "WeightedNormalModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*WeightedNormalModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(WeightedNormalModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(WeightedNormalModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "WeldModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*WeldModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(WeldModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(WeldModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "WhiteBalanceModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*WhiteBalanceModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(WhiteBalanceModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(WhiteBalanceModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "WipeVars":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*WipeVars, blk.Hdr.Count)
				for i := range bodies {
					body := new(WipeVars)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(WipeVars)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "WireframeModifierData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*WireframeModifierData, blk.Hdr.Count)
				for i := range bodies {
					body := new(WireframeModifierData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(WireframeModifierData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "WorkSpace":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*WorkSpace, blk.Hdr.Count)
				for i := range bodies {
					body := new(WorkSpace)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(WorkSpace)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "WorkSpaceDataRelation":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*WorkSpaceDataRelation, blk.Hdr.Count)
				for i := range bodies {
					body := new(WorkSpaceDataRelation)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(WorkSpaceDataRelation)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "WorkSpaceInstanceHook":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*WorkSpaceInstanceHook, blk.Hdr.Count)
				for i := range bodies {
					body := new(WorkSpaceInstanceHook)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(WorkSpaceInstanceHook)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "WorkSpaceLayout":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*WorkSpaceLayout, blk.Hdr.Count)
				for i := range bodies {
					body := new(WorkSpaceLayout)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(WorkSpaceLayout)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "World":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*World, blk.Hdr.Count)
				for i := range bodies {
					body := new(World)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(World)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "XrActionMap":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*XrActionMap, blk.Hdr.Count)
				for i := range bodies {
					body := new(XrActionMap)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(XrActionMap)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "XrActionMapBinding":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*XrActionMapBinding, blk.Hdr.Count)
				for i := range bodies {
					body := new(XrActionMapBinding)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(XrActionMapBinding)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "XrActionMapItem":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*XrActionMapItem, blk.Hdr.Count)
				for i := range bodies {
					body := new(XrActionMapItem)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(XrActionMapItem)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "XrComponentPath":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*XrComponentPath, blk.Hdr.Count)
				for i := range bodies {
					body := new(XrComponentPath)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(XrComponentPath)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "XrSessionSettings":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*XrSessionSettings, blk.Hdr.Count)
				for i := range bodies {
					body := new(XrSessionSettings)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(XrSessionSettings)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "XrUserPath":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*XrUserPath, blk.Hdr.Count)
				for i := range bodies {
					body := new(XrUserPath)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(XrUserPath)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bAction":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BAction, blk.Hdr.Count)
				for i := range bodies {
					body := new(BAction)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BAction)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bActionChannel":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BActionChannel, blk.Hdr.Count)
				for i := range bodies {
					body := new(BActionChannel)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BActionChannel)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bActionConstraint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BActionConstraint, blk.Hdr.Count)
				for i := range bodies {
					body := new(BActionConstraint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BActionConstraint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bActionGroup":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BActionGroup, blk.Hdr.Count)
				for i := range bodies {
					body := new(BActionGroup)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BActionGroup)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bActionModifier":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BActionModifier, blk.Hdr.Count)
				for i := range bodies {
					body := new(BActionModifier)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BActionModifier)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bActionStrip":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BActionStrip, blk.Hdr.Count)
				for i := range bodies {
					body := new(BActionStrip)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BActionStrip)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bAddon":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BAddon, blk.Hdr.Count)
				for i := range bodies {
					body := new(BAddon)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BAddon)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bAnimVizSettings":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BAnimVizSettings, blk.Hdr.Count)
				for i := range bodies {
					body := new(BAnimVizSettings)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BAnimVizSettings)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bArmature":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BArmature, blk.Hdr.Count)
				for i := range bodies {
					body := new(BArmature)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BArmature)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bArmatureConstraint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BArmatureConstraint, blk.Hdr.Count)
				for i := range bodies {
					body := new(BArmatureConstraint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BArmatureConstraint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bCameraSolverConstraint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BCameraSolverConstraint, blk.Hdr.Count)
				for i := range bodies {
					body := new(BCameraSolverConstraint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BCameraSolverConstraint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bChildOfConstraint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BChildOfConstraint, blk.Hdr.Count)
				for i := range bodies {
					body := new(BChildOfConstraint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BChildOfConstraint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bClampToConstraint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BClampToConstraint, blk.Hdr.Count)
				for i := range bodies {
					body := new(BClampToConstraint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BClampToConstraint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bConstraint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BConstraint, blk.Hdr.Count)
				for i := range bodies {
					body := new(BConstraint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BConstraint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bConstraintChannel":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BConstraintChannel, blk.Hdr.Count)
				for i := range bodies {
					body := new(BConstraintChannel)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BConstraintChannel)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bConstraintTarget":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BConstraintTarget, blk.Hdr.Count)
				for i := range bodies {
					body := new(BConstraintTarget)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BConstraintTarget)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bDampTrackConstraint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BDampTrackConstraint, blk.Hdr.Count)
				for i := range bodies {
					body := new(BDampTrackConstraint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BDampTrackConstraint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bDeformGroup":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BDeformGroup, blk.Hdr.Count)
				for i := range bodies {
					body := new(BDeformGroup)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BDeformGroup)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bDistLimitConstraint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BDistLimitConstraint, blk.Hdr.Count)
				for i := range bodies {
					body := new(BDistLimitConstraint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BDistLimitConstraint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bDopeSheet":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BDopeSheet, blk.Hdr.Count)
				for i := range bodies {
					body := new(BDopeSheet)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BDopeSheet)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bFaceMap":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BFaceMap, blk.Hdr.Count)
				for i := range bodies {
					body := new(BFaceMap)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BFaceMap)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bFollowPathConstraint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BFollowPathConstraint, blk.Hdr.Count)
				for i := range bodies {
					body := new(BFollowPathConstraint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BFollowPathConstraint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bFollowTrackConstraint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BFollowTrackConstraint, blk.Hdr.Count)
				for i := range bodies {
					body := new(BFollowTrackConstraint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BFollowTrackConstraint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bGPDcontrolpoint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BGPDcontrolpoint, blk.Hdr.Count)
				for i := range bodies {
					body := new(BGPDcontrolpoint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BGPDcontrolpoint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bGPDcurve":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BGPDcurve, blk.Hdr.Count)
				for i := range bodies {
					body := new(BGPDcurve)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BGPDcurve)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bGPDcurve_point":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BGPDcurve_point, blk.Hdr.Count)
				for i := range bodies {
					body := new(BGPDcurve_point)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BGPDcurve_point)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bGPDframe":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BGPDframe, blk.Hdr.Count)
				for i := range bodies {
					body := new(BGPDframe)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BGPDframe)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bGPDframe_Runtime":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BGPDframe_Runtime, blk.Hdr.Count)
				for i := range bodies {
					body := new(BGPDframe_Runtime)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BGPDframe_Runtime)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bGPDlayer":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BGPDlayer, blk.Hdr.Count)
				for i := range bodies {
					body := new(BGPDlayer)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BGPDlayer)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bGPDlayer_Mask":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BGPDlayer_Mask, blk.Hdr.Count)
				for i := range bodies {
					body := new(BGPDlayer_Mask)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BGPDlayer_Mask)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bGPDlayer_Runtime":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BGPDlayer_Runtime, blk.Hdr.Count)
				for i := range bodies {
					body := new(BGPDlayer_Runtime)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BGPDlayer_Runtime)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bGPDpalette":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BGPDpalette, blk.Hdr.Count)
				for i := range bodies {
					body := new(BGPDpalette)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BGPDpalette)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bGPDpalettecolor":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BGPDpalettecolor, blk.Hdr.Count)
				for i := range bodies {
					body := new(BGPDpalettecolor)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BGPDpalettecolor)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bGPDspoint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BGPDspoint, blk.Hdr.Count)
				for i := range bodies {
					body := new(BGPDspoint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BGPDspoint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bGPDspoint_Runtime":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BGPDspoint_Runtime, blk.Hdr.Count)
				for i := range bodies {
					body := new(BGPDspoint_Runtime)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BGPDspoint_Runtime)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bGPDstroke":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BGPDstroke, blk.Hdr.Count)
				for i := range bodies {
					body := new(BGPDstroke)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BGPDstroke)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bGPDstroke_Runtime":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BGPDstroke_Runtime, blk.Hdr.Count)
				for i := range bodies {
					body := new(BGPDstroke_Runtime)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BGPDstroke_Runtime)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bGPDtriangle":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BGPDtriangle, blk.Hdr.Count)
				for i := range bodies {
					body := new(BGPDtriangle)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BGPDtriangle)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bGPdata":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BGPdata, blk.Hdr.Count)
				for i := range bodies {
					body := new(BGPdata)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BGPdata)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bGPdata_Runtime":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BGPdata_Runtime, blk.Hdr.Count)
				for i := range bodies {
					body := new(BGPdata_Runtime)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BGPdata_Runtime)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bGPgrid":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BGPgrid, blk.Hdr.Count)
				for i := range bodies {
					body := new(BGPgrid)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BGPgrid)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bIKParam":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BIKParam, blk.Hdr.Count)
				for i := range bodies {
					body := new(BIKParam)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BIKParam)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bItasc":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BItasc, blk.Hdr.Count)
				for i := range bodies {
					body := new(BItasc)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BItasc)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bKinematicConstraint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BKinematicConstraint, blk.Hdr.Count)
				for i := range bodies {
					body := new(BKinematicConstraint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BKinematicConstraint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bLocLimitConstraint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BLocLimitConstraint, blk.Hdr.Count)
				for i := range bodies {
					body := new(BLocLimitConstraint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BLocLimitConstraint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bLocateLikeConstraint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BLocateLikeConstraint, blk.Hdr.Count)
				for i := range bodies {
					body := new(BLocateLikeConstraint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BLocateLikeConstraint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bLockTrackConstraint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BLockTrackConstraint, blk.Hdr.Count)
				for i := range bodies {
					body := new(BLockTrackConstraint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BLockTrackConstraint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bMinMaxConstraint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BMinMaxConstraint, blk.Hdr.Count)
				for i := range bodies {
					body := new(BMinMaxConstraint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BMinMaxConstraint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bMotionPath":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BMotionPath, blk.Hdr.Count)
				for i := range bodies {
					body := new(BMotionPath)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BMotionPath)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bMotionPathVert":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BMotionPathVert, blk.Hdr.Count)
				for i := range bodies {
					body := new(BMotionPathVert)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BMotionPathVert)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bNode":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BNode, blk.Hdr.Count)
				for i := range bodies {
					body := new(BNode)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BNode)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bNodeInstanceKey":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BNodeInstanceKey, blk.Hdr.Count)
				for i := range bodies {
					body := new(BNodeInstanceKey)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BNodeInstanceKey)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bNodeLink":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BNodeLink, blk.Hdr.Count)
				for i := range bodies {
					body := new(BNodeLink)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BNodeLink)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bNodeSocket":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BNodeSocket, blk.Hdr.Count)
				for i := range bodies {
					body := new(BNodeSocket)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BNodeSocket)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bNodeSocketValueBoolean":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BNodeSocketValueBoolean, blk.Hdr.Count)
				for i := range bodies {
					body := new(BNodeSocketValueBoolean)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BNodeSocketValueBoolean)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bNodeSocketValueCollection":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BNodeSocketValueCollection, blk.Hdr.Count)
				for i := range bodies {
					body := new(BNodeSocketValueCollection)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BNodeSocketValueCollection)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bNodeSocketValueFloat":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BNodeSocketValueFloat, blk.Hdr.Count)
				for i := range bodies {
					body := new(BNodeSocketValueFloat)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BNodeSocketValueFloat)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bNodeSocketValueImage":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BNodeSocketValueImage, blk.Hdr.Count)
				for i := range bodies {
					body := new(BNodeSocketValueImage)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BNodeSocketValueImage)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bNodeSocketValueInt":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BNodeSocketValueInt, blk.Hdr.Count)
				for i := range bodies {
					body := new(BNodeSocketValueInt)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BNodeSocketValueInt)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bNodeSocketValueMaterial":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BNodeSocketValueMaterial, blk.Hdr.Count)
				for i := range bodies {
					body := new(BNodeSocketValueMaterial)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BNodeSocketValueMaterial)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bNodeSocketValueObject":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BNodeSocketValueObject, blk.Hdr.Count)
				for i := range bodies {
					body := new(BNodeSocketValueObject)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BNodeSocketValueObject)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bNodeSocketValueRGBA":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BNodeSocketValueRGBA, blk.Hdr.Count)
				for i := range bodies {
					body := new(BNodeSocketValueRGBA)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BNodeSocketValueRGBA)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bNodeSocketValueString":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BNodeSocketValueString, blk.Hdr.Count)
				for i := range bodies {
					body := new(BNodeSocketValueString)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BNodeSocketValueString)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bNodeSocketValueTexture":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BNodeSocketValueTexture, blk.Hdr.Count)
				for i := range bodies {
					body := new(BNodeSocketValueTexture)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BNodeSocketValueTexture)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bNodeSocketValueVector":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BNodeSocketValueVector, blk.Hdr.Count)
				for i := range bodies {
					body := new(BNodeSocketValueVector)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BNodeSocketValueVector)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bNodeStack":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BNodeStack, blk.Hdr.Count)
				for i := range bodies {
					body := new(BNodeStack)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BNodeStack)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bNodeTree":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BNodeTree, blk.Hdr.Count)
				for i := range bodies {
					body := new(BNodeTree)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BNodeTree)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bNodeTreePath":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BNodeTreePath, blk.Hdr.Count)
				for i := range bodies {
					body := new(BNodeTreePath)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BNodeTreePath)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bObjectSolverConstraint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BObjectSolverConstraint, blk.Hdr.Count)
				for i := range bodies {
					body := new(BObjectSolverConstraint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BObjectSolverConstraint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bPathCompare":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BPathCompare, blk.Hdr.Count)
				for i := range bodies {
					body := new(BPathCompare)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BPathCompare)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bPivotConstraint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BPivotConstraint, blk.Hdr.Count)
				for i := range bodies {
					body := new(BPivotConstraint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BPivotConstraint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bPose":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BPose, blk.Hdr.Count)
				for i := range bodies {
					body := new(BPose)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BPose)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bPoseChannel":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BPoseChannel, blk.Hdr.Count)
				for i := range bodies {
					body := new(BPoseChannel)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BPoseChannel)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bPoseChannel_Runtime":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BPoseChannel_Runtime, blk.Hdr.Count)
				for i := range bodies {
					body := new(BPoseChannel_Runtime)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BPoseChannel_Runtime)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bPythonConstraint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BPythonConstraint, blk.Hdr.Count)
				for i := range bodies {
					body := new(BPythonConstraint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BPythonConstraint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bRigidBodyJointConstraint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BRigidBodyJointConstraint, blk.Hdr.Count)
				for i := range bodies {
					body := new(BRigidBodyJointConstraint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BRigidBodyJointConstraint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bRotLimitConstraint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BRotLimitConstraint, blk.Hdr.Count)
				for i := range bodies {
					body := new(BRotLimitConstraint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BRotLimitConstraint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bRotateLikeConstraint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BRotateLikeConstraint, blk.Hdr.Count)
				for i := range bodies {
					body := new(BRotateLikeConstraint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BRotateLikeConstraint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bSameVolumeConstraint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BSameVolumeConstraint, blk.Hdr.Count)
				for i := range bodies {
					body := new(BSameVolumeConstraint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BSameVolumeConstraint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bScreen":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BScreen, blk.Hdr.Count)
				for i := range bodies {
					body := new(BScreen)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BScreen)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bShrinkwrapConstraint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BShrinkwrapConstraint, blk.Hdr.Count)
				for i := range bodies {
					body := new(BShrinkwrapConstraint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BShrinkwrapConstraint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bSizeLikeConstraint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BSizeLikeConstraint, blk.Hdr.Count)
				for i := range bodies {
					body := new(BSizeLikeConstraint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BSizeLikeConstraint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bSizeLimitConstraint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BSizeLimitConstraint, blk.Hdr.Count)
				for i := range bodies {
					body := new(BSizeLimitConstraint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BSizeLimitConstraint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bSound":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BSound, blk.Hdr.Count)
				for i := range bodies {
					body := new(BSound)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BSound)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bSplineIKConstraint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BSplineIKConstraint, blk.Hdr.Count)
				for i := range bodies {
					body := new(BSplineIKConstraint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BSplineIKConstraint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bStretchToConstraint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BStretchToConstraint, blk.Hdr.Count)
				for i := range bodies {
					body := new(BStretchToConstraint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BStretchToConstraint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bTheme":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BTheme, blk.Hdr.Count)
				for i := range bodies {
					body := new(BTheme)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BTheme)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bToolRef":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BToolRef, blk.Hdr.Count)
				for i := range bodies {
					body := new(BToolRef)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BToolRef)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bTrackToConstraint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BTrackToConstraint, blk.Hdr.Count)
				for i := range bodies {
					body := new(BTrackToConstraint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BTrackToConstraint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bTransLikeConstraint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BTransLikeConstraint, blk.Hdr.Count)
				for i := range bodies {
					body := new(BTransLikeConstraint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BTransLikeConstraint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bTransformCacheConstraint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BTransformCacheConstraint, blk.Hdr.Count)
				for i := range bodies {
					body := new(BTransformCacheConstraint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BTransformCacheConstraint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bTransformConstraint":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BTransformConstraint, blk.Hdr.Count)
				for i := range bodies {
					body := new(BTransformConstraint)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BTransformConstraint)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bUUID":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BUUID, blk.Hdr.Count)
				for i := range bodies {
					body := new(BUUID)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BUUID)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bUserAssetLibrary":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BUserAssetLibrary, blk.Hdr.Count)
				for i := range bodies {
					body := new(BUserAssetLibrary)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BUserAssetLibrary)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bUserMenu":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BUserMenu, blk.Hdr.Count)
				for i := range bodies {
					body := new(BUserMenu)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BUserMenu)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bUserMenuItem":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BUserMenuItem, blk.Hdr.Count)
				for i := range bodies {
					body := new(BUserMenuItem)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BUserMenuItem)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bUserMenuItem_Menu":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BUserMenuItem_Menu, blk.Hdr.Count)
				for i := range bodies {
					body := new(BUserMenuItem_Menu)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BUserMenuItem_Menu)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bUserMenuItem_Op":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BUserMenuItem_Op, blk.Hdr.Count)
				for i := range bodies {
					body := new(BUserMenuItem_Op)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BUserMenuItem_Op)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "bUserMenuItem_Prop":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*BUserMenuItem_Prop, blk.Hdr.Count)
				for i := range bodies {
					body := new(BUserMenuItem_Prop)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(BUserMenuItem_Prop)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "rctf":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Rctf, blk.Hdr.Count)
				for i := range bodies {
					body := new(Rctf)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Rctf)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "rcti":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Rcti, blk.Hdr.Count)
				for i := range bodies {
					body := new(Rcti)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Rcti)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "tPaletteColorHSV":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*TPaletteColorHSV, blk.Hdr.Count)
				for i := range bodies {
					body := new(TPaletteColorHSV)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(TPaletteColorHSV)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "uiFontStyle":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*UiFontStyle, blk.Hdr.Count)
				for i := range bodies {
					body := new(UiFontStyle)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(UiFontStyle)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "uiList":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*UiList, blk.Hdr.Count)
				for i := range bodies {
					body := new(UiList)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(UiList)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "uiPanelColors":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*UiPanelColors, blk.Hdr.Count)
				for i := range bodies {
					body := new(UiPanelColors)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(UiPanelColors)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "uiPreview":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*UiPreview, blk.Hdr.Count)
				for i := range bodies {
					body := new(UiPreview)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(UiPreview)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "uiStyle":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*UiStyle, blk.Hdr.Count)
				for i := range bodies {
					body := new(UiStyle)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(UiStyle)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "uiWidgetColors":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*UiWidgetColors, blk.Hdr.Count)
				for i := range bodies {
					body := new(UiWidgetColors)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(UiWidgetColors)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "uiWidgetStateColors":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*UiWidgetStateColors, blk.Hdr.Count)
				for i := range bodies {
					body := new(UiWidgetStateColors)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(UiWidgetStateColors)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "vec2f":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Vec2f, blk.Hdr.Count)
				for i := range bodies {
					body := new(Vec2f)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Vec2f)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "vec2s":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Vec2s, blk.Hdr.Count)
				for i := range bodies {
					body := new(Vec2s)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Vec2s)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "vec3f":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*Vec3f, blk.Hdr.Count)
				for i := range bodies {
					body := new(Vec3f)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(Vec3f)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "wmKeyConfig":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*WmKeyConfig, blk.Hdr.Count)
				for i := range bodies {
					body := new(WmKeyConfig)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(WmKeyConfig)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "wmKeyConfigPref":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*WmKeyConfigPref, blk.Hdr.Count)
				for i := range bodies {
					body := new(WmKeyConfigPref)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(WmKeyConfigPref)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "wmKeyMap":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*WmKeyMap, blk.Hdr.Count)
				for i := range bodies {
					body := new(WmKeyMap)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(WmKeyMap)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "wmKeyMapDiffItem":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*WmKeyMapDiffItem, blk.Hdr.Count)
				for i := range bodies {
					body := new(WmKeyMapDiffItem)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(WmKeyMapDiffItem)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "wmKeyMapItem":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*WmKeyMapItem, blk.Hdr.Count)
				for i := range bodies {
					body := new(WmKeyMapItem)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(WmKeyMapItem)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "wmOperator":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*WmOperator, blk.Hdr.Count)
				for i := range bodies {
					body := new(WmOperator)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(WmOperator)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "wmOwnerID":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*WmOwnerID, blk.Hdr.Count)
				for i := range bodies {
					body := new(WmOwnerID)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(WmOwnerID)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "wmWindow":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*WmWindow, blk.Hdr.Count)
				for i := range bodies {
					body := new(WmWindow)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(WmWindow)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "wmWindowManager":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*WmWindowManager, blk.Hdr.Count)
				for i := range bodies {
					body := new(WmWindowManager)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(WmWindowManager)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		case "wmXrData":
			if blk.Hdr.Count > 1 {
				// Parse block body structures.
				bodies := make([]*WmXrData, blk.Hdr.Count)
				for i := range bodies {
					body := new(WmXrData)
					err = binary.Read(r, order, body)
					if err != nil {
						return err
					}
					bodies[i] = body
				}
				blk.Body = bodies
			} else {
				// Parse block body structure.
				body := new(WmXrData)
				err = binary.Read(r, order, body)
				if err != nil {
					return err
				}
				blk.Body = body
			}
			/// ### [ tmp ] ###
			// Verify that all bytes in the block body have been read.
			buf, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}
			if len(buf) > 0 {
				log.Printf("%d unread bytes in %q.", len(buf), typ)
				log.Printf("blk.Hdr: %#v\n", blk.Hdr)
				log.Println(hex.Dump(buf))
				os.Exit(1)
			}
			/// ### [/ tmp ] ###
		}
	}

	return nil
}
